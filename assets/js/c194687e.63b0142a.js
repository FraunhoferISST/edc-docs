"use strict";(self.webpackChunkedc_docs=self.webpackChunkedc_docs||[]).push([[4059],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>u});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),c=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=c(e.components);return r.createElement(s.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),h=c(n),u=a,m=h["".concat(s,".").concat(u)]||h[u]||p[u]||i;return n?r.createElement(m,o(o({ref:t},d),{},{components:n})):r.createElement(m,o({ref:t},d))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=h;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,o[1]=l;for(var c=2;c<i;c++)o[c]=n[c];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},9874:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>l,toc:()=>c});var r=n(7462),a=(n(7294),n(3905));const i={},o="Technical concept to simplify the FederatedCatalog",l={unversionedId:"submodule/Connector/docs/developer/decision-records/2022-07-22-simplify-fcc/README",id:"submodule/Connector/docs/developer/decision-records/2022-07-22-simplify-fcc/README",title:"Technical concept to simplify the FederatedCatalog",description:"Decision",source:"@site/docs/submodule/Connector/docs/developer/decision-records/2022-07-22-simplify-fcc/README.md",sourceDirName:"submodule/Connector/docs/developer/decision-records/2022-07-22-simplify-fcc",slug:"/submodule/Connector/docs/developer/decision-records/2022-07-22-simplify-fcc/",permalink:"/edc-docs/docs/submodule/Connector/docs/developer/decision-records/2022-07-22-simplify-fcc/",draft:!1,editUrl:"https://github.com/FraunhoferISST/edc-docs/tree/master/docs/submodule/Connector/docs/developer/decision-records/2022-07-22-simplify-fcc/README.md",tags:[],version:"current",frontMatter:{}},s={},c=[{value:"Decision",id:"decision",level:2},{value:"Rationale",id:"rationale",level:2},{value:"Approach",id:"approach",level:2},{value:"1. Remove the <code>PartitionManager</code>",id:"1-remove-the-partitionmanager",level:3},{value:"2. Make the <code>WorkItemQueue</code> short-lived",id:"2-make-the-workitemqueue-short-lived",level:3},{value:"3. Make the <code>Crawler</code> short-lived",id:"3-make-the-crawler-short-lived",level:3},{value:"4. Have <code>Crawler</code>s directly write to the <code>FederatedCacheStore</code>",id:"4-have-crawlers-directly-write-to-the-federatedcachestore",level:3}],d={toc:c};function p(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"technical-concept-to-simplify-the-federatedcatalog"},"Technical concept to simplify the FederatedCatalog"),(0,a.kt)("h2",{id:"decision"},"Decision"),(0,a.kt)("p",null,"We will simplify the FederatedCatalog in the aspects outlined in this document, because experience shows that the\ninitial complexity and versatility is in fact not needed.\nThe intended audience are developers, who are writing code for the FC and adopters who use and operate an FC."),(0,a.kt)("h2",{id:"rationale"},"Rationale"),(0,a.kt)("p",null,"The Federated Catalog was originally designed with the greatest flexibility and versatility in mind. For instance\nit has a ",(0,a.kt)("inlineCode",{parentName:"p"},"PartitionManager"),", that allows for partitioning a dataspace, e.g. by geographic areas."),(0,a.kt)("p",null,"Similarly, all components such as work queues, worker threads (",(0,a.kt)("inlineCode",{parentName:"p"},"Crawler"),"s) and the persistence pipeline are decoupled\nusing queues and parallel processing to enable the utmost independence and extensibility."),(0,a.kt)("p",null,"Practical applications so far have shown that all this complexity is not needed, rather, it makes the FC architecture\nhard to understand and hard to maintain."),(0,a.kt)("p",null,"Reducing complexity of the code base will be beneficial in several ways: code paths are easier to understand, the code\nbecomes easier to test and is less prone to implementation errors."),(0,a.kt)("h2",{id:"approach"},"Approach"),(0,a.kt)("p",null,"We therefore propose the following changes and simplifications:"),(0,a.kt)("h3",{id:"1-remove-the-partitionmanager"},"1. Remove the ",(0,a.kt)("inlineCode",{parentName:"h3"},"PartitionManager")),(0,a.kt)("p",null,"Partitioning would likely be done using a different approach, such as deployment paradigms, so the partition manager can\nbe deleted."),(0,a.kt)("p",null,"This means the ",(0,a.kt)("inlineCode",{parentName:"p"},"FederatedCatalogCacheExtension")," directly instantiates the ",(0,a.kt)("inlineCode",{parentName:"p"},"ExecutionPlan"),", and starts it."),(0,a.kt)("h3",{id:"2-make-the-workitemqueue-short-lived"},"2. Make the ",(0,a.kt)("inlineCode",{parentName:"h3"},"WorkItemQueue")," short-lived"),(0,a.kt)("p",null,"When the ",(0,a.kt)("inlineCode",{parentName:"p"},"ExecutionPlan")," is run, it fetches all ",(0,a.kt)("inlineCode",{parentName:"p"},"FederatedCacheNode")," elements from the ",(0,a.kt)("inlineCode",{parentName:"p"},"FederatedCacheNodeDirectory"),",\ninstantiates a new ",(0,a.kt)("inlineCode",{parentName:"p"},"WorkItemQueue")," and inserts the elements into it. The crawlers then set off and drain the queue. This\nmeans that a new queue is used for every crawl-run (assuming periodic crawling). Aside from (small) resource\nimprovements, it makes the entire FC more stateless."),(0,a.kt)("h3",{id:"3-make-the-crawler-short-lived"},"3. Make the ",(0,a.kt)("inlineCode",{parentName:"h3"},"Crawler")," short-lived"),(0,a.kt)("p",null,"Currently, crawlers are instantiated once and re-used on every crawl-run. Between runs, they needlessly poll the queue.\nWith this proposal I suggest that the ",(0,a.kt)("inlineCode",{parentName:"p"},"ExecutionPlan")," directly instantiates the crawlers (e.g. through\na ",(0,a.kt)("inlineCode",{parentName:"p"},"Supplier")," or a ",(0,a.kt)("inlineCode",{parentName:"p"},"Function"),") and sets them off in its ",(0,a.kt)("inlineCode",{parentName:"p"},"run")," method, passing the next ",(0,a.kt)("inlineCode",{parentName:"p"},"WorkItem")," as argument."),(0,a.kt)("p",null,"Consequently, the ",(0,a.kt)("inlineCode",{parentName:"p"},"ExecutionPlan")," maintains a list of ",(0,a.kt)("inlineCode",{parentName:"p"},"Crawlers"),", tracks their state (running vs finished), and removes\nthem from its internal list once they are done. It then instantiates new ones until the ",(0,a.kt)("inlineCode",{parentName:"p"},"WorkItemQueue"),' is empty. That\nway, crawlers can be simplified greatly, because they do not have to implement "polling the queue" anymore, thus\nreducing code complexity. With this, they will also mimic the semantics of a stateless "worker" more closely.'),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"Note: this would mean the logic to poll the queue gets moved into the ",(0,a.kt)("inlineCode",{parentName:"em"},"ExecutionPlan")," at which point we could think\nabout introducing a new collaborator object for the ",(0,a.kt)("inlineCode",{parentName:"em"},"ExecutionPlan"),", an ",(0,a.kt)("inlineCode",{parentName:"em"},"ExecutionManager")," of sorts.")),(0,a.kt)("h3",{id:"4-have-crawlers-directly-write-to-the-federatedcachestore"},"4. Have ",(0,a.kt)("inlineCode",{parentName:"h3"},"Crawler"),"s directly write to the ",(0,a.kt)("inlineCode",{parentName:"h3"},"FederatedCacheStore")),(0,a.kt)("p",null,"Currently, every ",(0,a.kt)("inlineCode",{parentName:"p"},"Crawler")," puts its result (i.e. a ",(0,a.kt)("inlineCode",{parentName:"p"},"UpdateResponse"),") into yet another queue, from which the ",(0,a.kt)("inlineCode",{parentName:"p"},"Loader"),"\ndequeues it and forwards it to the store.\nSince the persistence abstraction is handled by the store anyway, there really is no need for the indirection through\none (or potentially multiple) loaders anymore."))}p.isMDXComponent=!0}}]);