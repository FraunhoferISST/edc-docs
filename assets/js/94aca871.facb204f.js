"use strict";(self.webpackChunkedc_docs=self.webpackChunkedc_docs||[]).push([[6387],{3905:(e,n,t)=>{t.d(n,{Zo:()=>c,kt:()=>m});var o=t(7294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,o,a=function(e,n){if(null==e)return{};var t,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=o.createContext({}),d=function(e){var n=o.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},c=function(e){var n=d(e.components);return o.createElement(l.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},p=o.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=d(t),m=a,f=p["".concat(l,".").concat(m)]||p[m]||u[m]||i;return t?o.createElement(f,r(r({ref:n},c),{},{components:t})):o.createElement(f,r({ref:n},c))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,r=new Array(i);r[0]=p;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,r[1]=s;for(var d=2;d<i;d++)r[d]=t[d];return o.createElement.apply(null,r)}return o.createElement.apply(null,t)}p.displayName="MDXCreateElement"},4634:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>u,frontMatter:()=>i,metadata:()=>s,toc:()=>d});var o=t(7462),a=(t(7294),t(3905));const i={},r="Automated Documentation Tooling",s={unversionedId:"submodule/Connector/docs/developer/decision-records/2022-08-04-documentation-automation/README",id:"submodule/Connector/docs/developer/decision-records/2022-08-04-documentation-automation/README",title:"Automated Documentation Tooling",description:"Decision",source:"@site/docs/submodule/Connector/docs/developer/decision-records/2022-08-04-documentation-automation/README.md",sourceDirName:"submodule/Connector/docs/developer/decision-records/2022-08-04-documentation-automation",slug:"/submodule/Connector/docs/developer/decision-records/2022-08-04-documentation-automation/",permalink:"/edc-docs/docs/submodule/Connector/docs/developer/decision-records/2022-08-04-documentation-automation/",draft:!1,editUrl:"https://github.com/FraunhoferISST/edc-docs/tree/master/docs/submodule/Connector/docs/developer/decision-records/2022-08-04-documentation-automation/README.md",tags:[],version:"current",frontMatter:{}},l={},d=[{value:"Decision",id:"decision",level:2},{value:"Rationale",id:"rationale",level:2},{value:"Approach",id:"approach",level:2},{value:"The Module Manifest",id:"the-module-manifest",level:3},{value:"Module Manifest Generation",id:"module-manifest-generation",level:3},{value:"New Annotations and Conventions",id:"new-annotations-and-conventions",level:4},{value:"SPI Modules",id:"spi-modules",level:4},{value:"Extension Modules",id:"extension-modules",level:4},{value:"Markdown Documentation",id:"markdown-documentation",level:4},{value:"Manifest Publication and Resolution",id:"manifest-publication-and-resolution",level:3},{value:"Documentation Generation",id:"documentation-generation",level:3},{value:"Future Directions",id:"future-directions",level:2}],c={toc:d};function u(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,o.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"automated-documentation-tooling"},"Automated Documentation Tooling"),(0,a.kt)("h2",{id:"decision"},"Decision"),(0,a.kt)("p",null,"Creating documentation and managing extensions and their configuration properties in EDC is\ncurrently a time-consuming, manual process. A newly introduced module processor (described in the\nfollowing) ensures that the documentation is automatically collected and provided in a\nhuman-readable form (as markdown files)."),(0,a.kt)("h2",{id:"rationale"},"Rationale"),(0,a.kt)("p",null,"EDC runtimes are composed of ",(0,a.kt)("strong",{parentName:"p"},"SPI")," and ",(0,a.kt)("strong",{parentName:"p"},"extension")," modules that contribute capabilities to a\ncore subsystem. This modularity architecture is built on Java Service Provider loading. SPI modules\ndefine extensibility points via service interfaces, while extension modules register service\nimplementations."),(0,a.kt)("p",null,"Extension modules provide metadata that assists the EDC core subsystem to bootstrap a runtime\ncorrectly. The ",(0,a.kt)("inlineCode",{parentName:"p"},"@Inject")," annotation is used to declare required services and obtain a reference to\nthose services. The ",(0,a.kt)("inlineCode",{parentName:"p"},"@Provides")," annotation denotes which services an extension registers. A\ndependency DAG is created from this metadata, and a reverse topological sort is performed to\ndetermine the order extensions must be loaded."),(0,a.kt)("p",null,"This modularity architecture is simple but allows for a great deal of flexibility. For example,\nextensibility layers are created by adding additional SPI modules, and multiple runtimes can be\nassembled by including different module sets. However, as the number of extensions increases, the\nEDC will need additional metadata and automation to maintain ease of use. The following approach\noutlines tooling infrastructure that serves as a foundation for generating module manifests used to\ncreate documentation, facilitate extension discovery, and assist in runtime assembly."),(0,a.kt)("h2",{id:"approach"},"Approach"),(0,a.kt)("h3",{id:"the-module-manifest"},"The Module Manifest"),(0,a.kt)("p",null,"The EDC classifies modules as an SPI or an Extension. An SPI module defines one or more ",(0,a.kt)("strong",{parentName:"p"},"extension\npoints"),". By convention, an extension point is a Java interface, which is referred to as a service.\nAn extension module ",(0,a.kt)("strong",{parentName:"p"},"provides")," 0..N extension point implementations. An extension module may\ndepend on (",(0,a.kt)("strong",{parentName:"p"},"reference"),") 0..N services provided by other extensions. These relationships between\nmodules form a DAG."),(0,a.kt)("p",null,"The module manifest encapsulates this and other key metadata, including configuration settings and a\nMarkdown-based description. It has a canonical JSON serialization:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-json"},'[\n  {\n    "id": "org.eclipse.dataspaceconnector:base",\n    "version": "0.0.1-SNAPSHOT",\n    "name": "Core Services",\n    "type": "extension",\n    "categories": [],\n    "extensionPoints": [],\n    "provides": [\n      {\n        "service": "org.eclipse.dataspaceconnector.spi.system.health.HealthCheckService"\n      }\n    ],\n    "references": [\n      {\n        "service": "org.eclipse.dataspaceconnector.spi.system.ExecutorInstrumentation",\n        "required": false\n      }\n    ],\n    "configuration": [\n      {\n        "key": "edc.core.retry.retries.max",\n        "required": false,\n        "type": "string",\n        "description": "Specifies the maximum number of retries"\n      }\n    ],\n    "overview": "\u2026."\n  }\n]\n\n')),(0,a.kt)("p",null,"Serializing manifests in an array allows them to be concatenated for convenience."),(0,a.kt)("p",null,"As explained below, manifests can be resolved across artifact repositories and used to define the\nmodule DAG for a runtime. This serves as the foundation for future EDC tooling."),(0,a.kt)("h3",{id:"module-manifest-generation"},"Module Manifest Generation"),(0,a.kt)("p",null,"Module manifests are generated during build time by using the Java Compiler API via an annotation\nprocessor. The annotation processor introspects the compiler-generated AST to produce a manifest\nduring build-time. Since Gradle has built-in support for annotation processing, manifest generation\nis mostly transparent. The following example shows how the EDC module annotation processor can be\nenabled in the build configuration:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'dependencies {\n    annotationProcessor(project(":tooling:module-processor"))\n}\n\ntasks.withType<JavaCompile> {\n    val compilerArgs = options.compilerArgs\n    compilerArgs.add("-Aedc.version=${project.version}")\n    compilerArgs.add("-Aedc.id=${project.group}:${project.name}")\n}\n\n')),(0,a.kt)("p",null,"Once the processor is enabled, all module documentation, including configuration settings, are\nresolved by traversing parsed Java class files and rendered as a manifest."),(0,a.kt)("h4",{id:"new-annotations-and-conventions"},"New Annotations and Conventions"),(0,a.kt)("p",null,"Several new annotations are introduced to facilitate manifest generation."),(0,a.kt)("h4",{id:"spi-modules"},"SPI Modules"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"@Spi")," annotation is intended to be placed on the top-level ",(0,a.kt)("inlineCode",{parentName:"p"},"package-info.java")," in an SPI\nmodule:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},'\n@Target({ElementType.PACKAGE})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface Spi {\n\n    /**\n     * The readable module name.\n     */\n    String value();\n\n    /**\n     * Optional categories used to classify this module.\n     */\n    String[] categories() default "";\n}\n')),(0,a.kt)("p",null,"Service interfaces that define extension points are annotated with ",(0,a.kt)("inlineCode",{parentName:"p"},"@ExtensionPoint"),":"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\n@Inherited\n@Documented\npublic @interface ExtensionPoint {\n}\n")),(0,a.kt)("h4",{id:"extension-modules"},"Extension Modules"),(0,a.kt)("p",null,"Extension modules use the ",(0,a.kt)("inlineCode",{parentName:"p"},"@Extension")," annotation on the ",(0,a.kt)("inlineCode",{parentName:"p"},"SystemExtension")," class:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},'\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface Extension {\n\n    /**\n     * The readable module name.\n     */\n    String value();\n\n    /**\n     * Optional categories used to classify this module.\n     */\n    String[] categories() default "";\n\n}\n')),(0,a.kt)("p",null,"The annotation processor uses the existing ",(0,a.kt)("inlineCode",{parentName:"p"},"@Setting"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"@Provides"),", and ",(0,a.kt)("inlineCode",{parentName:"p"},"@Inject")," annotations.\nAn ",(0,a.kt)("inlineCode",{parentName:"p"},"@SettingContext")," provides for ",(0,a.kt)("inlineCode",{parentName:"p"},"ConfigMap")," support:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},"\n@Target({ElementType.TYPE, ElementType.FIELD})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface SettingContext {\n    String value();\n}\n")),(0,a.kt)("h4",{id:"markdown-documentation"},"Markdown Documentation"),(0,a.kt)("p",null,"SPI and Extension module documentation are taken from Javadoc on the ",(0,a.kt)("inlineCode",{parentName:"p"},"package-info.java"),"\nand ",(0,a.kt)("inlineCode",{parentName:"p"},"SystemExtension")," class respectively. The Javadoc will then be transformed into Markdown. This\napproach ensures that detailed user technical documentation remains in-sync with code-level\ndocumentation."),(0,a.kt)("p",null,"Settings are also be introspected and collated from code. For example, the following code are\nintrospected to produce two configuration entries, including proper resolution of constant values (\nincluding the ",(0,a.kt)("inlineCode",{parentName:"p"},"PREFIX")," symbol):"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},'private static final String PREFIX="edc.core.";\n\n@Setting("Specifies the maximum number of retries")\npublic static final String MAX_RETRIES=PREFIX+"retry.retries.max";\n\n@Setting\npublic static final String BACKOFF_MIN_MILLIS="edc.core.retry.backoff.min";\n')),(0,a.kt)("h3",{id:"manifest-publication-and-resolution"},"Manifest Publication and Resolution"),(0,a.kt)("p",null,"Manifests are published as a separate Maven classifier for their corresponding module. This enables\ntolling to resolve EDC manifests using existing Maven-based repositories."),(0,a.kt)("h3",{id:"documentation-generation"},"Documentation Generation"),(0,a.kt)("p",null,"As a second step, a Gradle plugin resolves module manifests from Maven archives and creates\nmarkdown-based documentation from the metadata they contain. This documentation can be integrated\nwith GitHub pages. ",(0,a.kt)("em",{parentName:"p"},"Note that generated documentation could include modules from remote\nrepositories (by following the Gradle dependency graph) and link to Javadoc for further detail.")),(0,a.kt)("h2",{id:"future-directions"},"Future Directions"),(0,a.kt)("p",null,"It will be possible to create additional tooling based on EDC module manifests. For example, runtime\nconfiguration templates can be produced by resolving module manifests referenced in a Gradle\nBill-of-Materials project. It will also be possible to build tools that categorize and discover\nextensions."))}u.isMDXComponent=!0}}]);