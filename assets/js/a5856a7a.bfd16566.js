"use strict";(self.webpackChunkedc_docs=self.webpackChunkedc_docs||[]).push([[6444],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>u});var i=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,i,o=function(e,t){if(null==e)return{};var n,i,o={},a=Object.keys(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)n=a[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var d=i.createContext({}),s=function(e){var t=i.useContext(d),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=s(e.components);return i.createElement(d.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},c=i.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,d=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),c=s(n),u=o,h=c["".concat(d,".").concat(u)]||c[u]||m[u]||a;return n?i.createElement(h,r(r({ref:t},p),{},{components:n})):i.createElement(h,r({ref:t},p))}));function u(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,r=new Array(a);r[0]=c;var l={};for(var d in t)hasOwnProperty.call(t,d)&&(l[d]=t[d]);l.originalType=e,l.mdxType="string"==typeof e?e:o,r[1]=l;for(var s=2;s<a;s++)r[s]=n[s];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}c.displayName="MDXCreateElement"},17890:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>r,default:()=>m,frontMatter:()=>a,metadata:()=>l,toc:()=>s});var i=n(87462),o=(n(67294),n(3905));const a={},r="Advanced dependency resolution: default provider methods",l={unversionedId:"submodule/Connector/docs/developer/default_provider_methods",id:"submodule/Connector/docs/developer/default_provider_methods",title:"Advanced dependency resolution: default provider methods",description:"This feature (and this document) is aimed at platform developers who intend to provide additional platform features. It",source:"@site/docs/submodule/Connector/docs/developer/default_provider_methods.md",sourceDirName:"submodule/Connector/docs/developer",slug:"/submodule/Connector/docs/developer/default_provider_methods",permalink:"/edc-docs/docs/submodule/Connector/docs/developer/default_provider_methods",draft:!1,editUrl:"https://github.com/FraunhoferISST/edc-docs/tree/master/docs/submodule/Connector/docs/developer/default_provider_methods.md",tags:[],version:"current",frontMatter:{}},d={},s=[{value:"Fallbacks versus extensibility",id:"fallbacks-versus-extensibility",level:2},{value:"Fallback implementations",id:"fallback-implementations",level:3},{value:"Extensibility",id:"extensibility",level:3},{value:"Deep-dive into extension lifecycle management",id:"deep-dive-into-extension-lifecycle-management",level:2},{value:"Example 1 - provider method",id:"example-1---provider-method",level:3},{value:"Example 2 - default provider method",id:"example-2---default-provider-method",level:3},{value:"Usage guidelines when using default providers",id:"usage-guidelines-when-using-default-providers",level:2}],p={toc:s};function m(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,i.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"advanced-dependency-resolution-default-provider-methods"},"Advanced dependency resolution: default provider methods"),(0,o.kt)("p",null,"This feature (and this document) is aimed at platform developers who intend to provide additional platform features. It\nis ",(0,o.kt)("strong",{parentName:"p"},"not")," intended for people who simply want to contribute a technology extension, such as a database implementation\nor a storage backend!"),(0,o.kt)("p",null,'In this document we will use the term "default provider" and "default provider method" synonymously to refer to a method\nannotated with ',(0,o.kt)("inlineCode",{parentName:"p"},"@Provider(isDefault=true)"),'. Similarly, "provider", "provider method" or "factory method"\nrefer to methods annotated with just ',(0,o.kt)("inlineCode",{parentName:"p"},"@Provider"),"."),(0,o.kt)("h2",{id:"fallbacks-versus-extensibility"},"Fallbacks versus extensibility"),(0,o.kt)("p",null,"Default provider methods are intended to provide fallback implementations for services rather than to achieve\nextensibility - that is what extensions are for. There is a subtle but important semantic difference between ",(0,o.kt)("em",{parentName:"p"},"fallback\nimplementations")," and ",(0,o.kt)("em",{parentName:"p"},"extensibility"),":"),(0,o.kt)("h3",{id:"fallback-implementations"},"Fallback implementations"),(0,o.kt)("p",null,"Fallbacks are meant as safety net, in case developers forget or don't want to add a specific implementation for a\nservice. It is there so as not to end up ",(0,o.kt)("em",{parentName:"p"},"without")," an implementation for a service interface. A good example for this\nare in-memory store implementations. It is expected that an actual persistence implementation is contributed by another\nextension. In-mem stores get you up and running quickly, but we wouldn't recommend using them in production\nenvironments. Typically, fallbacks should not have any dependencies onto other services."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Default-provided services, even though they are on the classpath, only get instantiated if there is no other\nimplementation.")),(0,o.kt)("h3",{id:"extensibility"},"Extensibility"),(0,o.kt)("p",null,"In contrast, ",(0,o.kt)("em",{parentName:"p"},"extensibility")," refers to the possibility of swapping out one implementation of a service for another by\nchoosing the respective module at compile time. Each implementation must therefore be contained in its own java module,\nand the choice between one or the other is made by referencing one or the other in the build file. The service\nimplementation is typically instantiated and provided by its own extension. In this case, the ",(0,o.kt)("inlineCode",{parentName:"p"},"@Provider"),"-annotation ",(0,o.kt)("strong",{parentName:"p"},"\nmust not")," have the ",(0,o.kt)("inlineCode",{parentName:"p"},"isDefault")," attribute. This is also the case if there will likely only ever be one implementation\nfor a service."),(0,o.kt)("p",null,"One example for extensibility is the ",(0,o.kt)("inlineCode",{parentName:"p"},"IdentityService"),": there could be several implementations for it (OAuth,\nDecentralizedIdentity, Keycloak etc.), but providing either one as default would make little sense, because all of them\nrequire external services to work. Each implementation would be in its own module and get instantiated by its own\nextension."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Provided services get instantiated only if they are on the classpath, but always get instantiated.")),(0,o.kt)("h2",{id:"deep-dive-into-extension-lifecycle-management"},"Deep-dive into extension lifecycle management"),(0,o.kt)("p",null,"Generally speaking every extension goes through these lifecycle stages during loading:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"inject"),": all fields annotated with ",(0,o.kt)("inlineCode",{parentName:"li"},"@Inject")," are resolved"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"initialize"),": the ",(0,o.kt)("inlineCode",{parentName:"li"},"initialize()")," method is invoked. All required collaborators are expected to be resolved after this."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"provide"),": all ",(0,o.kt)("inlineCode",{parentName:"li"},"@Provider")," methods are invoked, the object they return is registered in the context.")),(0,o.kt)("p",null,"Due to the fact that default provider methods act a safety net, they only get invoked if no other provider method offers\nthe same service type. However, what may be a bit misleading is the fact that they typically get invoked ",(0,o.kt)("em",{parentName:"p"},"during the\n",(0,o.kt)("inlineCode",{parentName:"em"},"inject")," phase"),". The following section will demonstrate this."),(0,o.kt)("h3",{id:"example-1---provider-method"},"Example 1 - provider method"),(0,o.kt)("p",null,"Recall that ",(0,o.kt)("inlineCode",{parentName:"p"},"@Provider")," methods get invoked regardless, and after the ",(0,o.kt)("inlineCode",{parentName:"p"},"initialze")," phase. That means, assuming both\nextensions are on the classpath, the extension that declares the provider method (= ",(0,o.kt)("inlineCode",{parentName:"p"},"ExtensionA"),") will get fully\ninstantiated before another extension (= ",(0,o.kt)("inlineCode",{parentName:"p"},"ExtensionB"),") can use the provided object:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"public class ExtensionA { // gets loaded first\n    @Inject\n    private SomeStore store; // provided by some other extension\n\n    @Provider\n    public SomeService getSomeService() {\n        return new SomeServiceImpl(store);\n    }\n}\n\npublic class ExtensionB { // gets loaded second\n    @Inject\n    private SomeService service;\n}\n")),(0,o.kt)("p",null,"After building the dependency graph, the loader mechanism would first fully construct ",(0,o.kt)("inlineCode",{parentName:"p"},"ExtensionA"),", i.e.\n",(0,o.kt)("inlineCode",{parentName:"p"},"getSomeService()")," is invoked, and the instance of ",(0,o.kt)("inlineCode",{parentName:"p"},"SomeServiceImpl")," is registered in the context. Note that this is\ndone regardless whether another extension ",(0,o.kt)("em",{parentName:"p"},"actually injects a ",(0,o.kt)("inlineCode",{parentName:"em"},"SomeService")),". After that, ",(0,o.kt)("inlineCode",{parentName:"p"},"ExtensionB")," gets constructed,\nand by the time it goes through its ",(0,o.kt)("inlineCode",{parentName:"p"},"inject")," phase, the injected ",(0,o.kt)("inlineCode",{parentName:"p"},"SomeService")," is already in the context, so the\n",(0,o.kt)("inlineCode",{parentName:"p"},"SomeService")," field gets resolved properly."),(0,o.kt)("h3",{id:"example-2---default-provider-method"},"Example 2 - default provider method"),(0,o.kt)("p",null,"Methods annotated with ",(0,o.kt)("inlineCode",{parentName:"p"},"@Provider(isDefault=true)")," only get invoked if there is no other provider method for that\nservice, and at the time when the corresponding ",(0,o.kt)("inlineCode",{parentName:"p"},"@Inject")," is resolved. Modifying example 1 slightly we get:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"public class ExtensionA {\n\n    @Inject\n    private SomeStore store;\n\n    @Provider(isDefault = true)\n    public SomeService getSomeService() {\n        return new SomeServiceImpl(store);\n    }\n}\n\npublic class ExtensionB {\n    @Inject\n    private SomeService service;\n}\n")),(0,o.kt)("p",null,"The biggest difference here is the point in time at which ",(0,o.kt)("inlineCode",{parentName:"p"},"getSomeService")," is invoked. Default provider methods get\ninvoked ",(0,o.kt)("em",{parentName:"p"},"when the ",(0,o.kt)("inlineCode",{parentName:"em"},"@Inject")," dependency is resolved"),', because that is the "latest" point in time that that decision can\nbe made. That means, they get invoked during ',(0,o.kt)("inlineCode",{parentName:"p"},"ExtensionB"),"'s inject phase, and ",(0,o.kt)("em",{parentName:"p"},"not")," during ",(0,o.kt)("inlineCode",{parentName:"p"},"ExtensionA"),"'s provide phase.\nThere is no guarantee that ",(0,o.kt)("inlineCode",{parentName:"p"},"ExtensionA")," is already initialized by that time, because the extension loader does not know\nwhether it needs to invoke ",(0,o.kt)("inlineCode",{parentName:"p"},"getSomeService")," at all, until the very last moment, i.e. when resolving ",(0,o.kt)("inlineCode",{parentName:"p"},"ExtensionB"),"'s\n",(0,o.kt)("inlineCode",{parentName:"p"},"service")," field. By that time, the dependency graph is already built."),(0,o.kt)("p",null,"Consequently, default provider methods could (and likely would) get invoked before the defining extension's ",(0,o.kt)("inlineCode",{parentName:"p"},"provide"),"\nphase has completed. They even could get invoked before the ",(0,o.kt)("inlineCode",{parentName:"p"},"initialize")," phase has completed: consider the following\nsituation the previous example:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"all implementors of ",(0,o.kt)("inlineCode",{parentName:"li"},"ServiceExtension")," get constructed by the Java ",(0,o.kt)("inlineCode",{parentName:"li"},"ServiceLoader")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"ExtensionB")," gets loaded, runs through its inject phase"),(0,o.kt)("li",{parentName:"ol"},"no provider for ",(0,o.kt)("inlineCode",{parentName:"li"},"SomeService"),", thus the default provider kicks in"),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("inlineCode",{parentName:"li"},"ExtensionA.getSomeService()")," is invoked, but ",(0,o.kt)("inlineCode",{parentName:"li"},"ExtensionA")," is not yet loaded -> ",(0,o.kt)("inlineCode",{parentName:"li"},"store")," is null"),(0,o.kt)("li",{parentName:"ol"},"-> potential NPE")),(0,o.kt)("p",null,"Because there is no explicit ordering in how the ",(0,o.kt)("inlineCode",{parentName:"p"},"@Inject")," fields are resolved, the order may depend on several factors,\nlike the Java version or specific JVM used, the classloader and/or implementation of reflection used, etc."),(0,o.kt)("h2",{id:"usage-guidelines-when-using-default-providers"},"Usage guidelines when using default providers"),(0,o.kt)("p",null,"From the previous sections and the examples demonstrated above we can derive a few important guidelines:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"do not use them to achieve extensibility. That is what extensions are for."),(0,o.kt)("li",{parentName:"ul"},"use them only to provide a ",(0,o.kt)("em",{parentName:"li"},"fallback implementation")),(0,o.kt)("li",{parentName:"ul"},"they should not depend on other injected fields (as those may still be null)"),(0,o.kt)("li",{parentName:"ul"},"they should be in their own dedicated extension (cf. ",(0,o.kt)("inlineCode",{parentName:"li"},"DefaultServicesExtension"),") and Java module"),(0,o.kt)("li",{parentName:"ul"},"do not provide and inject the same service in one extension"),(0,o.kt)("li",{parentName:"ul"},"rule of thumb: unless you know exactly what you're doing and why you need them - don't use them!")))}m.isMDXComponent=!0}}]);