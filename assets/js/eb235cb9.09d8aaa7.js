"use strict";(self.webpackChunkedc_docs=self.webpackChunkedc_docs||[]).push([[3477],{3905:(e,o,t)=>{t.d(o,{Zo:()=>d,kt:()=>g});var r=t(7294);function n(e,o,t){return o in e?Object.defineProperty(e,o,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[o]=t,e}function a(e,o){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);o&&(r=r.filter((function(o){return Object.getOwnPropertyDescriptor(e,o).enumerable}))),t.push.apply(t,r)}return t}function c(e){for(var o=1;o<arguments.length;o++){var t=null!=arguments[o]?arguments[o]:{};o%2?a(Object(t),!0).forEach((function(o){n(e,o,t[o])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(o){Object.defineProperty(e,o,Object.getOwnPropertyDescriptor(t,o))}))}return e}function i(e,o){if(null==e)return{};var t,r,n=function(e,o){if(null==e)return{};var t,r,n={},a=Object.keys(e);for(r=0;r<a.length;r++)t=a[r],o.indexOf(t)>=0||(n[t]=e[t]);return n}(e,o);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)t=a[r],o.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(n[t]=e[t])}return n}var s=r.createContext({}),l=function(e){var o=r.useContext(s),t=o;return e&&(t="function"==typeof e?e(o):c(c({},o),e)),t},d=function(e){var o=l(e.components);return r.createElement(s.Provider,{value:o},e.children)},p={inlineCode:"code",wrapper:function(e){var o=e.children;return r.createElement(r.Fragment,{},o)}},u=r.forwardRef((function(e,o){var t=e.components,n=e.mdxType,a=e.originalType,s=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),u=l(t),g=n,m=u["".concat(s,".").concat(g)]||u[g]||p[g]||a;return t?r.createElement(m,c(c({ref:o},d),{},{components:t})):r.createElement(m,c({ref:o},d))}));function g(e,o){var t=arguments,n=o&&o.mdxType;if("string"==typeof e||n){var a=t.length,c=new Array(a);c[0]=u;var i={};for(var s in o)hasOwnProperty.call(o,s)&&(i[s]=o[s]);i.originalType=e,i.mdxType="string"==typeof e?e:n,c[1]=i;for(var l=2;l<a;l++)c[l]=t[l];return r.createElement.apply(null,c)}return r.createElement.apply(null,t)}u.displayName="MDXCreateElement"},7501:(e,o,t)=>{t.r(o),t.d(o,{assets:()=>s,contentTitle:()=>c,default:()=>p,frontMatter:()=>a,metadata:()=>i,toc:()=>l});var r=t(7462),n=(t(7294),t(3905));const a={},c="Option 1: JaCoCo",i={unversionedId:"submodule/Connector/docs/developer/decision-records/2022-02-10-code-coverage/jacoco",id:"submodule/Connector/docs/developer/decision-records/2022-02-10-code-coverage/jacoco",title:"Option 1: JaCoCo",description:"JaCoCo (Java Code Coverage) is a popular and mature open-source tool. It runs as a Java agent during test execution, to capture which lines are exercised during which test.",source:"@site/docs/submodule/Connector/docs/developer/decision-records/2022-02-10-code-coverage/jacoco.md",sourceDirName:"submodule/Connector/docs/developer/decision-records/2022-02-10-code-coverage",slug:"/submodule/Connector/docs/developer/decision-records/2022-02-10-code-coverage/jacoco",permalink:"/edc-docs/docs/submodule/Connector/docs/developer/decision-records/2022-02-10-code-coverage/jacoco",draft:!1,editUrl:"https://github.com/FraunhoferISST/edc-docs/tree/master/docs/submodule/Connector/docs/developer/decision-records/2022-02-10-code-coverage/jacoco.md",tags:[],version:"current",frontMatter:{}},s={},l=[],d={toc:l};function p(e){let{components:o,...a}=e;return(0,n.kt)("wrapper",(0,r.Z)({},d,a,{components:o,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"option-1-jacoco"},"Option 1: JaCoCo"),(0,n.kt)("p",null,"JaCoCo (Java Code Coverage) is a popular and mature open-source tool. It runs as a Java agent during test execution, to capture which lines are exercised during which test."),(0,n.kt)("p",null,"Capturing coverage for a particular project in JaCoCo is straightforward, using the ",(0,n.kt)("a",{parentName:"p",href:"https://docs.gradle.org/current/userguide/jacoco_plugin.html"},"Gradle JaCoCo Plugin"),"."),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre",className:"language-kotlin"},"// build.gradle.kts\nplugins {\n    jacoco\n}\n")),(0,n.kt)("p",null,"This yields an HTML report."),(0,n.kt)("p",null,(0,n.kt)("img",{alt:"Code Coverage with JaCoCo",src:t(954).Z,width:"2580",height:"460"})),(0,n.kt)("p",null,"The report can be drilled to highlight covered lines (green), not covered lines (red), and lines where some execution branches are not covered (orange)."),(0,n.kt)("p",null,(0,n.kt)("img",{alt:"Code Coverage with JaCoCo",src:t(5662).Z,width:"1868",height:"184"})),(0,n.kt)("p",null,"This configuration has limited value since each project produces its own report. Furthermore, there is no indication of whether a given commit is increasing or decreasing coverage, and in which areas of the code."),(0,n.kt)("h1",{id:"option-2-jacoco-with-aggregation"},"Option 2: JaCoCo with aggregation"),(0,n.kt)("p",null,"The Gradle documentation includes a sample for ",(0,n.kt)("a",{parentName:"p",href:"https://docs.gradle.org/current/samples/sample_jvm_multi_project_with_code_coverage.html"},"Reporting code coverage across multiple sub-projects with JaCoCo"),". The sample explains how to generate a single aggregated report."),(0,n.kt)("p",null,"We were not able to get the sample working in the EDC repository."),(0,n.kt)("p",null,"In any case, extensive complex Kotlin code needs to be added to the build. This is concerning for maintainability."),(0,n.kt)("p",null,"As it would anyway not solve the problem that code coverage is best analyzed relatively to a previous commit, we did not attempt further to get the sample working."))}p.isMDXComponent=!0},5662:(e,o,t)=>{t.d(o,{Z:()=>r});const r=t.p+"assets/images/code-coverage-jacoco-code-ca610c6a62ddc932a504a27743c961c6.png"},954:(e,o,t)=>{t.d(o,{Z:()=>r});const r=t.p+"assets/images/code-coverage-jacoco-summary-caa9106ee4eb3befe01f3244a96629ff.png"}}]);