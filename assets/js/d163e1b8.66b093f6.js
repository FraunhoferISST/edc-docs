"use strict";(self.webpackChunkedc_docs=self.webpackChunkedc_docs||[]).push([[8948],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>c});var a=n(67294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function r(e,t){if(null==e)return{};var n,a,s=function(e,t){if(null==e)return{};var n,a,s={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var l=a.createContext({}),u=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=u(e.components);return a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,s=e.mdxType,i=e.originalType,l=e.parentName,d=r(e,["components","mdxType","originalType","parentName"]),m=u(n),c=s,h=m["".concat(l,".").concat(c)]||m[c]||p[c]||i;return n?a.createElement(h,o(o({ref:t},d),{},{components:n})):a.createElement(h,o({ref:t},d))}));function c(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var i=n.length,o=new Array(i);o[0]=m;var r={};for(var l in t)hasOwnProperty.call(t,l)&&(r[l]=t[l]);r.originalType=e,r.mdxType="string"==typeof e?e:s,o[1]=r;for(var u=2;u<i;u++)o[u]=n[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},15371:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>r,toc:()=>u});var a=n(87462),s=(n(67294),n(3905));const i={},o="Writing Tests",r={unversionedId:"submodule/Connector/docs/developer/testing",id:"submodule/Connector/docs/developer/testing",title:"Writing Tests",description:"Adding EDC test fixtures",source:"@site/docs/submodule/Connector/docs/developer/testing.md",sourceDirName:"submodule/Connector/docs/developer",slug:"/submodule/Connector/docs/developer/testing",permalink:"/edc-docs/docs/submodule/Connector/docs/developer/testing",draft:!1,editUrl:"https://github.com/FraunhoferISST/edc-docs/tree/master/docs/submodule/Connector/docs/developer/testing.md",tags:[],version:"current",frontMatter:{}},l={},u=[{value:"Adding EDC test fixtures",id:"adding-edc-test-fixtures",level:2},{value:"Controlling test verbosity",id:"controlling-test-verbosity",level:2},{value:"Definition and distinction",id:"definition-and-distinction",level:2},{value:"Integration Tests",id:"integration-tests",level:2},{value:"TL;DR",id:"tldr",level:3},{value:"When to use them",id:"when-to-use-them",level:3},{value:"Coding Guidelines",id:"coding-guidelines",level:3},{value:"Running them locally",id:"running-them-locally",level:3},{value:"Running them in the CI pipeline",id:"running-them-in-the-ci-pipeline",level:3},{value:"Do&#39;s and Don&#39;ts",id:"dos-and-donts",level:3},{value:"System tests",id:"system-tests",level:2},{value:"Performance tests",id:"performance-tests",level:2}],d={toc:u};function p(e){let{components:t,...i}=e;return(0,s.kt)("wrapper",(0,a.Z)({},d,i,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"writing-tests"},"Writing Tests"),(0,s.kt)("h2",{id:"adding-edc-test-fixtures"},"Adding EDC test fixtures"),(0,s.kt)("p",null,"To add EDC test utilities and test fixtures to downstream projects, simply add the following Gradle dependency:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-kotlin"},'  testImplementation("org.eclipse.edc:common-junit:<version>")\n')),(0,s.kt)("h2",{id:"controlling-test-verbosity"},"Controlling test verbosity"),(0,s.kt)("p",null,"To run tests verbosely (displaying test events and output and error streams to the console), use the following system\nproperty:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-shell"},"./gradlew test -PverboseTest\n")),(0,s.kt)("h2",{id:"definition-and-distinction"},"Definition and distinction"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("em",{parentName:"li"},"unit tests")," test one single class by stubbing or mocking dependencies."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#integration-tests"},(0,s.kt)("em",{parentName:"a"},"integration test"))," tests one particular aspect of a software, which may involve external\nsystems."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("a",{parentName:"li",href:"#system-tests"},(0,s.kt)("em",{parentName:"a"},"system tests"))," are end-2-end tests that rely on the ",(0,s.kt)("em",{parentName:"li"},"entire")," system to be present.")),(0,s.kt)("h2",{id:"integration-tests"},"Integration Tests"),(0,s.kt)("h3",{id:"tldr"},"TL;DR"),(0,s.kt)("p",null,"Use integration tests only when necessary, keep them concise, implement them in a defensive manner using timeouts and\nrandomized names, setup external systems during the workflow."),(0,s.kt)("h3",{id:"when-to-use-them"},"When to use them"),(0,s.kt)("p",null,"Generally we should aim at writing unit tests rather than integration tests, because they are simpler, more stable and\ntypically run faster. Sometimes that's not (easily) possible, especially when an implementation relies on an external\nsystem that is not easily mocked or stubbed such as cloud-based databases."),(0,s.kt)("p",null,"Therefore, in many cases writing unit tests is more involved that writing an integration test, for example say we wanted\nto test our implementation of a CosmosDB-backed queue. We would have to mock the behaviour of the CosmosDB API, which -\nwhile certainly possible - can get complicated pretty quickly. Now we still might do that for simpler scenarios, but\neventually we might want to write an integration test that uses a CosmosDB test instance."),(0,s.kt)("h3",{id:"coding-guidelines"},"Coding Guidelines"),(0,s.kt)("p",null,"EDC codebase has few annotations and these annotation focuses on two important aspects:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Exclude integration tests by default from JUnit test runner as these tests relies on external systems which might not\nbe available during a local execution."),(0,s.kt)("li",{parentName:"ul"},"Categorize integration tests with help of\n",(0,s.kt)("a",{parentName:"li",href:"https://junit.org/junit5/docs/current/user-guide/#writing-tests-tagging-and-filtering"},"JUnit Tags"),".")),(0,s.kt)("p",null,"Following are some available annotations:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"@IntegrationTest"),": Marks an integration test with ",(0,s.kt)("inlineCode",{parentName:"li"},"IntegrationTest")," Junit tag. This is the default tag and can be\nused if you do not want to specify any other tags on your test to do further categorization.")),(0,s.kt)("p",null,"Below annotations are used to categorize integration tests based on the runtime components that must be available for\nthe test to run. All of these annotations are composite annotations and contains ",(0,s.kt)("inlineCode",{parentName:"p"},"@IntegrationTest")," annotation as well."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"@AzureStorageIntegrationTest"),": Marks an integration test with ",(0,s.kt)("inlineCode",{parentName:"li"},"AzureStorageIntegrationTest")," Junit tag. This should be\nused when the integration test requires the Azure Storage emulator to run."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"@AzureCosmosDbIntegrationTest"),": Marks an integration test with ",(0,s.kt)("inlineCode",{parentName:"li"},"AzureCosmosDbIntegrationTest")," Junit tag. This should\nbe used when the integration test requires the Azure CosmosDB emulator to run."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"@AwsS3IntegrationTest"),": Marks an integration test with ",(0,s.kt)("inlineCode",{parentName:"li"},"AwsS3IntegrationTest")," Junit tag. This should be used when the\nintegration test requires the AWS S3 storage emulator to run."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"@DapsTest"),": Marks an integration test with ",(0,s.kt)("inlineCode",{parentName:"li"},"DapsIntegrationTest")," Junit tag. This should be used when the integration\ntest is requires Daps IAM endpoint to run."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"@OpenTelemetryIntegrationTest"),": Marks an integration test with ",(0,s.kt)("inlineCode",{parentName:"li"},"OpenTelemetryIntegrationTest")," Junit Tag. This should\nbe used for integration tests that require the\n",(0,s.kt)("a",{parentName:"li",href:"https://github.com/open-telemetry/opentelemetry-java-instrumentation"},"OpenTelemetry agent"),", for example tests about\nmetrics and traces."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"@EndToEndTest"),": Marks an integration test with ",(0,s.kt)("inlineCode",{parentName:"li"},"EndToEndTest")," Junit Tag. This should be used when entire system is"),(0,s.kt)("li",{parentName:"ul"},"involved in a test."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("inlineCode",{parentName:"li"},"@ComponentTest"),": Marks an integration test with ",(0,s.kt)("inlineCode",{parentName:"li"},"ComponentTest")," Junit Tag. This should be used when the test does not\nuse an external system, but uses actual collaborator objects instead of mocks.")),(0,s.kt)("p",null,"We encourage you to use these available annotation but if your integration test does not fit in one of these available\nannotations, and you want to categorize them based on their technologies then feel free to create a new annotations but\nmake sure to use composite annotations which contains ",(0,s.kt)("inlineCode",{parentName:"p"},"@IntegrationTest"),". If you do not wish to categorize based on\ntheir technologies then you can use already available ",(0,s.kt)("inlineCode",{parentName:"p"},"@IntegrationTest")," annotation."),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"By default, JUnit test runner ignores all integration tests because in root ",(0,s.kt)("inlineCode",{parentName:"li"},"build.gradle.kts")," file we have excluded\nall tests marked with ",(0,s.kt)("inlineCode",{parentName:"li"},"IntegrationTest")," Junit tag."),(0,s.kt)("li",{parentName:"ul"},"If your integration test does not rely on an external system then you may not want to use above-mentioned annotations.")),(0,s.kt)("p",null,"All integration tests should specify annotation to categorize them and the ",(0,s.kt)("inlineCode",{parentName:"p"},'"...IntegrationTest"')," postfix to distinguish\nthem clearly from unit tests. They should reside in the same package as unit tests because all tests should maintain\npackage consistency to their test subject."),(0,s.kt)("p",null,"Any credentials, secrets, passwords, etc. that are required by the integration tests should be passed in using\nenvironment variables. A good way to access them is ",(0,s.kt)("inlineCode",{parentName:"p"},"ConfigurationFunctions.propOrEnv()")," because then the credentials\ncan also be supplied via system properties."),(0,s.kt)("p",null,"There is no one-size-fits-all guideline whether to perform setup tasks in the ",(0,s.kt)("inlineCode",{parentName:"p"},"@BeforeAll")," or ",(0,s.kt)("inlineCode",{parentName:"p"},"@BeforeEach"),", it will\ndepend on the concrete system you're using. As a general rule of thumb long-running one-time setup should be done in\nthe ",(0,s.kt)("inlineCode",{parentName:"p"},"@BeforeAll")," so as not to extend the run-time of the test unnecessarily. In contrast, in most cases it is ",(0,s.kt)("strong",{parentName:"p"},"not"),"\nadvisable to deploy/provision the external system itself in either of those methods. In other words, provisioning a\nCosmosDB or spinning up a Postgres docker container directly from test code should generally be avoided, because it will\nintroduce code that has nothing to do with the test and may cause security problems (privilege escalation through the\nDocker API), etc."),(0,s.kt)("p",null,"This does not at all discourage the use of external test environments like containers, rather, the external system\nshould be deployed in the CI script (e.g. through Github's ",(0,s.kt)("inlineCode",{parentName:"p"},"services")," feature), or there might even be a dedicated test\ninstance running continuously, e.g. a CosmosDB test instance in Azure. In the latter case we need to be careful to avoid\nconflicts (e.g. database names) when multiple test runners access that system simultaneously and to properly clean-up\nany residue before and after the test."),(0,s.kt)("h3",{id:"running-them-locally"},"Running them locally"),(0,s.kt)("p",null,"As mentioned above the JUnit runner won't pick up integration tests unless a tag is provided. For example to run\n",(0,s.kt)("inlineCode",{parentName:"p"},"Azure CosmosDB")," integration tests pass ",(0,s.kt)("inlineCode",{parentName:"p"},"includeTags")," parameter with tag value to the ",(0,s.kt)("inlineCode",{parentName:"p"},"gradlew")," command:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},'./gradlew test -p path/to/module -DincludeTags="AzureCosmosDbIntegrationTest"\n')),(0,s.kt)("p",null,"if needed to run all types of tests(e.g. unit & integration) then it can be achieved by passing the ",(0,s.kt)("inlineCode",{parentName:"p"},"runAllTests=true"),"\nparameter to the ",(0,s.kt)("inlineCode",{parentName:"p"},"gradlew")," command:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},'./gradlew test -DrunAllTests="true"\n')),(0,s.kt)("p",null,"For example to run all integration tests from Azure cosmos db module and its sub-modules:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-bash"},'./gradlew -p extensions/azure/cosmos test -DincludeTags="AzureCosmosDbIntegrationTest"\n')),(0,s.kt)("p",null,(0,s.kt)("em",{parentName:"p"},"Command as ",(0,s.kt)("inlineCode",{parentName:"em"},'./gradlew :extensions:azure:cosmos test -DincludeTags="AzureCosmosDbIntegrationTest"')," does not execute\ntests from all sub-modules so we need to use ",(0,s.kt)("inlineCode",{parentName:"em"},"-p")," to specify the module project path.")),(0,s.kt)("p",null,"Cosmos DB integration tests are run by default against a locally\nrunning ",(0,s.kt)("a",{parentName:"p",href:"https://docs.microsoft.com/azure/cosmos-db/local-emulator"},"Cosmos DB Emulator"),". You can also use an instance of\nCosmos DB running in Azure, in which case you should set the ",(0,s.kt)("inlineCode",{parentName:"p"},"COSMOS_KEY")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"COSMOS_URL")," environment variables."),(0,s.kt)("h3",{id:"running-them-in-the-ci-pipeline"},"Running them in the CI pipeline"),(0,s.kt)("p",null,"All integration tests should go into the ",(0,s.kt)("a",{parentName:"p",href:"/.github/workflows/verify.yaml"},"verify workflow"),', every\n"technology" should have its own job, and technology specific tests can be targeted using Junit tags with\n',(0,s.kt)("inlineCode",{parentName:"p"},"-DincludeTags")," property as described above in document."),(0,s.kt)("p",null,"A GitHub ",(0,s.kt)("a",{parentName:"p",href:"https://docs.github.com/actions/creating-actions/creating-a-composite-action"},"composite action")," was created to\nencapsulate the tasks of running tests and uploading test reports as artifacts for publication."),(0,s.kt)("p",null,"A final job named  ",(0,s.kt)("inlineCode",{parentName:"p"},"Upload-Test-Report"),"  should depend on all test jobs. It assembles all individual test reports."),(0,s.kt)("p",null,"For example let's assume we've implemented a Postgres-based Asset Index, then the integration tests for that should go\ninto a \"Postgres\" ",(0,s.kt)("inlineCode",{parentName:"p"},"job"),", and every module that adds a test (here: ",(0,s.kt)("inlineCode",{parentName:"p"},"extensions:postgres:assetindex"),") should apply a\ncomposite annotation (here: ",(0,s.kt)("inlineCode",{parentName:"p"},"@PostgresIntegrationTest")," adding a tag ",(0,s.kt)("inlineCode",{parentName:"p"},"PostgresIntegrationTest"),") on its integration tests.\nThis tagging will be used by the CI pipeline step to target and execute the integration tests related to Postgres."),(0,s.kt)("p",null,"Let's also make sure that the code is checked out before and integration tests only run on the upstream repo."),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-yaml"},"jobs:\n  Postgres-Integration-Tests:\n    # run only on upstream repo\n    if: github.repository_owner == 'eclipse-edc'\n    runs-on: ubuntu-latest\n\n    # taken from https://docs.github.com/en/actions/using-containerized-services/creating-postgresql-service-containers\n    services:\n      # Label used to access the service container\n      postgres:\n        # Docker Hub image\n        image: postgres\n        # Provide the password for postgres\n        env:\n          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}\n        # Set health checks to wait until postgres has started\n        options: >-\n          --health-cmd pg_isready\n          --health-interval 10s\n          --health-timeout 5s\n          --health-retries 5\n\n    env:\n      POSTGRES_USER: ${{ secrets.POSTGRES_USERNAME }}\n      POSTGRES_PWD: ${{ secrets.POSTGRES_PASSWORD }}\n\n    steps:\n      - uses: ./.github/actions/setup-build\n\n      - name: Postgres Tests   #just an example!\n        uses: ./.github/actions/run-tests\n        with:\n          command: ./gradlew -p extensions/postgres test -DincludeTags=\"PostgresIntegrationTest\"\n\n  [ ... ]\n\nUpload-Test-Report:\n  needs:\n    [ ... ]\n    - Postgres-Integration-Tests\n  [ ... ]\n")),(0,s.kt)("p",null,"It is important to note that the secrets (here: ",(0,s.kt)("inlineCode",{parentName:"p"},"POSTGRES_USERNAME")," and ",(0,s.kt)("inlineCode",{parentName:"p"},"POSTGRES_PASSWORD"),") must be defined within the\nrepository's settings and that can only be done by a committer with temporary admin access, so be sure to contact them\nbefore submitting your PR."),(0,s.kt)("h3",{id:"dos-and-donts"},"Do's and Don'ts"),(0,s.kt)("p",null,"DO:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"use integration tests sparingly and only when unit tests are not practical"),(0,s.kt)("li",{parentName:"ul"},"deploy the external system as ",(0,s.kt)("inlineCode",{parentName:"li"},"service")," directly in the workflow or"),(0,s.kt)("li",{parentName:"ul"},"use a dedicated always-on test instance"),(0,s.kt)("li",{parentName:"ul"},"take into account that external systems might experience transient failures or have degraded performance, so test\nmethods should have a timeout so as not to block the runner indefinitely."),(0,s.kt)("li",{parentName:"ul"},"use randomized strings for things like database/table/bucket/container names, etc., especially when the external\nsystem does not get destroyed after the test.")),(0,s.kt)("p",null,"DO NOT:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"try to cover everything with integration tests. It's typically a code smell if there are no corresponding unit tests\nfor an integration test."),(0,s.kt)("li",{parentName:"ul"},"slip into a habit of testing the external system rather than your usage of it"),(0,s.kt)("li",{parentName:"ul"},"store secrets directly in the code. Github will warn about that."),(0,s.kt)("li",{parentName:"ul"},"perform complex external system setup in ",(0,s.kt)("inlineCode",{parentName:"li"},"@BeforeEach")," or ",(0,s.kt)("inlineCode",{parentName:"li"},"@BeforeAll"))),(0,s.kt)("h2",{id:"system-tests"},"System tests"),(0,s.kt)("p",null,"System tests are needed when an entire feature should be tested, end to end."),(0,s.kt)("p",null,"To write a system test two parts are needed:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("em",{parentName:"li"},"runner"),": a module that contains the test logic"),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("em",{parentName:"li"},"runtimes"),": one or more modules that define a standalone runtime (e.g. a complete EDC definition)")),(0,s.kt)("p",null,"The runner can load an EDC runtime by using the ",(0,s.kt)("inlineCode",{parentName:"p"},"@RegisterExtension")," annotation (example\nin ",(0,s.kt)("a",{target:"_blank",href:n(39178).Z},(0,s.kt)("code",null,"FileTransferIntegrationTest")),")\n."),(0,s.kt)("p",null,"To make sure that the runtime extensions are correctly built and available, they need to be set as dependency of the\nrunner module as ",(0,s.kt)("inlineCode",{parentName:"p"},"testCompileOnly"),". (example in ",(0,s.kt)("a",{parentName:"p",href:"/system-tests/tests/build.gradle.kts"},(0,s.kt)("inlineCode",{parentName:"a"},"build.gradle.kts")),")."),(0,s.kt)("p",null,"This would permit the dependency isolation between runtimes (very important the test need to run two different\ncomponents like a control plane and a data plane)."),(0,s.kt)("h2",{id:"performance-tests"},"Performance tests"),(0,s.kt)("p",null,"To evaluate performance of the system such tests can be added. Each performance tests should be tagged with\n",(0,s.kt)("inlineCode",{parentName:"p"},"@PerformanceTest")," annotation. To maintain historic data about system performance these tests are executed nightly via\ngithub workflow ",(0,s.kt)("inlineCode",{parentName:"p"},"performancetests.yml"),", test reports are uploaded as an github artifact at end of workflow run."))}p.isMDXComponent=!0},39178:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/FileTransferIntegrationTest-511a3648e8559c582836402eb327c494.java"}}]);