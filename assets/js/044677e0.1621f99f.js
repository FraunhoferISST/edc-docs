"use strict";(self.webpackChunkedc_docs=self.webpackChunkedc_docs||[]).push([[8799],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var s=a.createContext({}),c=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,s=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),u=c(n),m=o,h=u["".concat(s,".").concat(m)]||u[m]||d[m]||r;return n?a.createElement(h,l(l({ref:t},p),{},{components:n})):a.createElement(h,l({ref:t},p))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,l=new Array(r);l[0]=u;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:o,l[1]=i;for(var c=2;c<r;c++)l[c]=n[c];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},46105:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>l,default:()=>d,frontMatter:()=>r,metadata:()=>i,toc:()=>c});var a=n(87462),o=(n(67294),n(3905));const r={},l="Technical concept DPF Selector",i={unversionedId:"submodule/Connector/docs/developer/dpf_selector",id:"submodule/Connector/docs/developer/dpf_selector",title:"Technical concept DPF Selector",description:'This document presents the technical concept for the "DataPlaneFramework Selector", henceforth "DPF Selector" or "DPFS"',source:"@site/docs/submodule/Connector/docs/developer/dpf_selector.md",sourceDirName:"submodule/Connector/docs/developer",slug:"/submodule/Connector/docs/developer/dpf_selector",permalink:"/edc-docs/docs/submodule/Connector/docs/developer/dpf_selector",draft:!1,editUrl:"https://github.com/FraunhoferISST/edc-docs/tree/master/docs/submodule/Connector/docs/developer/dpf_selector.md",tags:[],version:"current",frontMatter:{}},s={},c=[{value:"Terminology",id:"terminology",level:2},{value:"Proposed solution",id:"proposed-solution",level:2},{value:"API/SPI considerations",id:"apispi-considerations",level:3},{value:"Single vs Multi DPF",id:"single-vs-multi-dpf",level:3},{value:"Store concepts",id:"store-concepts",level:3},{value:"Selection Strategies",id:"selection-strategies",level:3},{value:"Deployment scenarios",id:"deployment-scenarios",level:2},{value:"Future developments",id:"future-developments",level:2}],p={toc:c};function d(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"technical-concept-dpf-selector"},"Technical concept DPF Selector"),(0,o.kt)("p",null,'This document presents the technical concept for the "DataPlaneFramework Selector", henceforth "DPF Selector" or "DPFS"\nfor short. In typical clustered environments (Kubernetes) we anticipate a multitude of connector runtimes and DPF\nruntimes, scaling independently of each other, depending on a particular use case. Also, the DPFs may have different\nconfigurations, so they may not even be in the same replica set (in Azure this would be Availability Sets vs. Scale\nSets).'),(0,o.kt)("p",null,"Further, we assume that every connector has access to multiple DPF runtimes, even if they are not homogenous replicas.\nFor example, some deployments may choose to have one dedicated DPF per geographical region, or even per ",(0,o.kt)("inlineCode",{parentName:"p"},"DataSink"),"\n/",(0,o.kt)("inlineCode",{parentName:"p"},"DataSource")," pair."),(0,o.kt)("p",null,"Whenever a data transfer request hits the connector, it eventually will delegate the transfer to the DPF. For that, it\nneeds to know ",(0,o.kt)("em",{parentName:"p"},"which DPF to delegate to"),". In simple deployments, there may just be one single DPF, so the DPF selector\nis essentially a preconfigured value, but in more complex scenarios sophisticated algorithms may be employed to select\nthe best-fitting DPF."),(0,o.kt)("p",null,'This is not dissimilar to how load-balancers work, one key difference being that the DPF selector will distribute the\nrequest based on not just the load situation, but also based on request metadata or even functional requirements (e.g. "\nmust be able to store in Azure BlobStore").'),(0,o.kt)("p",null,"Another key difference to (most) load balancers is the modularity and flexibility of the DPF selector: it can be\nembedded into another process (e.g. a connector), standalone, it can handle different storage and API technologies, it\nitself could theoretically run clustered, etc."),(0,o.kt)("h2",{id:"terminology"},"Terminology"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"DPF: one DataPlaneFramework runtime instance"),(0,o.kt)("li",{parentName:"ul"},'CP: one ControlPlane instance, often used synonymous to "connector"'),(0,o.kt)("li",{parentName:"ul"},"connector: one connector runtime"),(0,o.kt)("li",{parentName:"ul"},"selector: one DPF selector runtime, either embedded or standalone"),(0,o.kt)("li",{parentName:"ul"},"DataSource: one particular implementation that the DPF uses to fetch data from (e.g. Amazon S3)"),(0,o.kt)("li",{parentName:"ul"},"DataSink: one particular implementation of a data destination (e.g. AzureBlob)"),(0,o.kt)("li",{parentName:"ul"},'Seeding: the process of pre-populating a database. Often used synonymous to "loading".'),(0,o.kt)("li",{parentName:"ul"},"Feature pack: a collection of Java modules that fulfill one particular purpose, typically accompanied by a BOM (\nbill-of-materials)")),(0,o.kt)("h2",{id:"proposed-solution"},"Proposed solution"),(0,o.kt)("p",null,'We propose to create another "feature pack" in the EDC repository, essentially a meta module\nnamed ',(0,o.kt)("inlineCode",{parentName:"p"},":extensions:data-plane-selector"),", which will contain (at least) the following submodules:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"selector-spi"),": for interfaces and extensibility points such as store, strategy"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"data-plane-selector-api"),": REST API"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"selector-core"),": common code, default implementations for store and strategies")),(0,o.kt)("p",null,"Furthermore there should be a ",(0,o.kt)("inlineCode",{parentName:"p"},"selector-launcher")," in the ",(0,o.kt)("inlineCode",{parentName:"p"},"launchers")," directory containing a build file for standalone\ndeployment."),(0,o.kt)("p",null,"Centrally to the DPF selector is an interface ",(0,o.kt)("inlineCode",{parentName:"p"},"DataPlaneSelector")," whos purpose is to select a DPF instance based on an\nincoming ",(0,o.kt)("inlineCode",{parentName:"p"},"DataRequest")," and an optional ",(0,o.kt)("inlineCode",{parentName:"p"},"SelectionStrategy"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"public interface DataPlaneSelector {\n\n    default DataPlaneInstance select(DataRequest dataRequest) {\n        return select(dataRequest, new RandomSelectionStrategy());\n    }\n\n    DataPlaneInstance select(DataRequest dataRequest, SelectionStrategy strategy);\n}\n")),(0,o.kt)("p",null,"The main business object is the ",(0,o.kt)("inlineCode",{parentName:"p"},"DataPlaneInstance")," which represents one particular DPF instance with circa the\nfollowing signature:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"public interface DataPlaneInstance {\n    boolean canHandle(DataRequest request);\n\n    URL getUrl(); //returns the url+path to the DataPlane API\n\n    int turnCount(); //how often selected\n\n    long lastActive(); //when selected last\n\n    Map<String, Object> getProperties(); //extensible properties\n}\n")),(0,o.kt)("p",null,"Thus, the ",(0,o.kt)("inlineCode",{parentName:"p"},"DataPlaneInstance")," itself determines whether it can support a particular data request, based on various\ncapabilities such as its ",(0,o.kt)("inlineCode",{parentName:"p"},"DataSink")," and ",(0,o.kt)("inlineCode",{parentName:"p"},"DataSource")," implementations, streaming capabilities, etc."),(0,o.kt)("p",null,"Requests come in either through an API or an SPI hit the ",(0,o.kt)("inlineCode",{parentName:"p"},"DataPlaneSelector"),", which then filters its list\nof ",(0,o.kt)("inlineCode",{parentName:"p"},"DataPlaneInstace")," records and selects the best fitting DPF based on a strategy. By default selection is made at\nrandom."),(0,o.kt)("h3",{id:"apispi-considerations"},"API/SPI considerations"),(0,o.kt)("p",null,"We'll provide both a REST API and a Java SPI (i.e. the ",(0,o.kt)("inlineCode",{parentName:"p"},"DataPlaneSelector"),"), so that the DPF selector can run embedded\nin another process, or as a standalone runtime. Both of those should offer the same functionality, which is:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"get-instance"),": selects the best-fit DPF for a ",(0,o.kt)("inlineCode",{parentName:"li"},"DataRequest"),", optionally accepts a ",(0,o.kt)("inlineCode",{parentName:"li"},"SelectionStrategy")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"add-instance"),": adds a ",(0,o.kt)("inlineCode",{parentName:"li"},"DataPlaneInstance")," to the internal store"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"remove-instance"),": removes a ",(0,o.kt)("inlineCode",{parentName:"li"},"DataPlaneInstance")," from the internal store")),(0,o.kt)("p",null,"Both the REST API and the SPI implement these use cases."),(0,o.kt)("h3",{id:"single-vs-multi-dpf"},"Single vs Multi DPF"),(0,o.kt)("p",null,"In case a particular deployment uses just one DPF, the entire selection process can be simplified to always return the\npre-configured DPF URL. This is likely to be used in end-to-end-test scenarios, demos or samples."),(0,o.kt)("h3",{id:"store-concepts"},"Store concepts"),(0,o.kt)("p",null,"The DPF selector needs a storage backend where it can save its ",(0,o.kt)("inlineCode",{parentName:"p"},"DataPlaneInstance")," objects. The default implementation\nwill be an in-memory one, but extensions can be provided for CosmosDB, SQL, etc."),(0,o.kt)("p",null,"Whether a centralized persistent or an ephemeral store should be used will largely depend on the deployment scenario and\nwhether the DPF selector runs standalone or embedded in the connector."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Seeding:")," As a starting point we will provide a mechanism to load a preconfigured list of DPF instances using the EDC\nconfiguration mechanism. Named properties similar will be used, similar to what we currently have for web contexts, for\nexample:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-properties"},"edc.dpf.selector.pod1.url=http://some.url\nedc.dpf.selector.pod1.someOtherProperty=...\n//...=\nedc.dpf.selector.pod2.url=http://some.other.url\nedc.dpf.selector.pod2.someOtherProperty=...\n")),(0,o.kt)("p",null,"In addition, using the aforementioned API, any sort of data seeding scenario is possible, e.g. terraform, a dedicated\nloader, scripting, etc."),(0,o.kt)("h3",{id:"selection-strategies"},"Selection Strategies"),(0,o.kt)("p",null,"A ",(0,o.kt)("inlineCode",{parentName:"p"},"SelectionStrategy")," (as in: ",(0,o.kt)("a",{parentName:"p",href:"https://en.wikipedia.org/wiki/Strategy_pattern"},"strategy pattern"),") influences the\nbest-fit criteria for a ",(0,o.kt)("inlineCode",{parentName:"p"},"DataPlaneInstance"),". By default, we will implement the following ones:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"RandomSelectionStrategy"),": will select one DPF instance at random. Assuming normal distribution of the RNG, all DPFs\nwill be selected at approximately equal frequency."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("inlineCode",{parentName:"li"},"RoundRobinSelectionStrategy"),': selects the "next" DPF instance in an ordered list. ',(0,o.kt)("strong",{parentName:"li"},"Requires state!")),(0,o.kt)("li",{parentName:"ul"},"[optional]"," ",(0,o.kt)("inlineCode",{parentName:"li"},"OldestNextSelectionStrategy"),": selects the DPF instance that was idle the longest")),(0,o.kt)("p",null,(0,o.kt)("em",{parentName:"p"},"Please note that when multiple DPF selector instances are used, some of the selection strategies only work as intended\nif DPF selectors share their storage, otherwise the counters would be inconsitent!")),(0,o.kt)("p",null,"All ",(0,o.kt)("inlineCode",{parentName:"p"},"SelectionStrategy")," objects must be registered with the DPF selector before it can be passed in through a REST API\nor used in the SPI. This requires the use of a ",(0,o.kt)("inlineCode",{parentName:"p"},"SelectionStrategyRegistry")," into which customer extensions can register\ntheir specific strategies."),(0,o.kt)("h2",{id:"deployment-scenarios"},"Deployment scenarios"),(0,o.kt)("p",null,"With this modular approach, the DPF selector can run as a standalone application, for example in a Kubernetes Deployment\nor as plain sidecar container. However, this type of deployment scenario practically ",(0,o.kt)("em",{parentName:"p"},"requires")," adding the ",(0,o.kt)("inlineCode",{parentName:"p"},"-api")," module\nto the build, otherwise no interaction with the selector is possible."),(0,o.kt)("p",null,"Another way of running a DPF selector would be as extension, i.e. embedded in an EDC connector runtime. In this scenario\nthe ",(0,o.kt)("inlineCode",{parentName:"p"},"-api")," module can be ignored, as all communication happens through the Java SPI. Again, situations with multiple\nconnector instances practically ",(0,o.kt)("em",{parentName:"p"},"require")," using a persistent centralized storage (such as CosmosDB)."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Client lib"),': it should be transparent for the connector whether an embedded or a remote DPF selector is used,\ntherefore we propose creating a small "DPF selector lib" in the EDC codebase, consisting of a single interface:'),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"public interface DataPlaneSelectorClient {\n    DataPlaneInstance select(DataRequest dataRequest);\n}\n\n// when the DPF selector is embedded --\x3e default\nclass LocalDataPlaneSelectorClient implements DataPlaneSelectorClient {\n    private final DataPlaneSelector selector;\n    private SelectionStrategy strategy; //could be null\n\n    // CTor(s)\n\n    public DataPlaneInstance select(DataRequest dataRequest) {\n        return strategy != null ? selector.select(dataRequest, strategy) : selector.select(dataRequest);\n    }\n}\n\n// when the DPF selector is remote\nclass RemoteDataPlaneSelectorClient implements DataPlaneSelectorClient {\n    private final EdcHttpClient client;\n    private String strategyName; //could be null\n\n    // CTor(s)\n\n    public DataPlaneInstance select(DataRequest dataRequest) {\n        //invoke REST API of the remote selector \n    }\n}\n")),(0,o.kt)("h2",{id:"future-developments"},"Future developments"),(0,o.kt)("p",null,"Once we have performance metrics and instrumentation built-in into the DPF, we can create a small extension that reports\nthose dynamic metrics back to the DPF selector, who then stores them and uses them as additional input parameter to the\nselection algorithm."),(0,o.kt)("p",null,"Another possible improvement would be a DPF selector that can interact with the Kubernetes backend and dynamically\nupdate its internal storage based on Kubernetes auto-scaling: when Kubernetes scales out the DPF pods, the selector\ntracks that and automatically updates its internal storage."))}d.isMDXComponent=!0}}]);