"use strict";(self.webpackChunkedc_docs=self.webpackChunkedc_docs||[]).push([[1909],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>p});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),d=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=d(e.components);return a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),m=d(n),p=r,h=m["".concat(s,".").concat(p)]||m[p]||u[p]||o;return n?a.createElement(h,i(i({ref:t},c),{},{components:n})):a.createElement(h,i({ref:t},c))}));function p(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=m;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var d=2;d<o;d++)i[d]=n[d];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},7218:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>d});var a=n(7462),r=(n(7294),n(3905));const o={},i="Using the Command Queue",l={unversionedId:"submodule/Connector/docs/developer/command-queue",id:"submodule/Connector/docs/developer/command-queue",title:"Using the Command Queue",description:"In many situations, especially when there are is parallel processing in multiple threads involved, we may run into situations that could potentially cause",source:"@site/docs/submodule/Connector/docs/developer/command-queue.md",sourceDirName:"submodule/Connector/docs/developer",slug:"/submodule/Connector/docs/developer/command-queue",permalink:"/edc-docs/docs/submodule/Connector/docs/developer/command-queue",draft:!1,editUrl:"https://github.com/FraunhoferISST/edc-docs/tree/master/docs/submodule/Connector/docs/developer/command-queue.md",tags:[],version:"current",frontMatter:{}},s={},d=[{value:"Problem statement",id:"problem-statement",level:2},{value:"When to use it",id:"when-to-use-it",level:2},{value:"How to use it",id:"how-to-use-it",level:2},{value:"Best practices",id:"best-practices",level:2},{value:"Further reading",id:"further-reading",level:2}],c={toc:d};function u(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"using-the-command-queue"},"Using the Command Queue"),(0,r.kt)("p",null,"In many situations, especially when there are is parallel processing in multiple threads involved, we may run into situations that could potentially cause\ninconsistencies. For the purposes of this document we'll use the ",(0,r.kt)("inlineCode",{parentName:"p"},"TransferProcessManager"),' ("TPM") as example, although the concept applies to other components\nas well.'),(0,r.kt)("h2",{id:"problem-statement"},"Problem statement"),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"TransferProcessManager")," automatically updates ",(0,r.kt)("inlineCode",{parentName:"p"},"TransferProcess"),' ("TP") objects according to its state machine and depending on external influence, e.g.\nprovisioning. This is done on a separate thread. However, there are situations, where those TransferProcesses need to be modified from a different thread, for\nexample a watchdog, that retires timed-out or stale TPs. Simply fetching the TP from the store, updating it and storing it again may cause race conditions, and\nit may cause the TP to be in an unexpected state.'),(0,r.kt)("p",null,"Thus, the ",(0,r.kt)("inlineCode",{parentName:"p"},"TransferProcessStore")," should never be accessed directly, instead every action that modifies a TP, that happens ",(0,r.kt)("em",{parentName:"p"},"outside")," of the TPM should be\nenqueued in the ",(0,r.kt)("inlineCode",{parentName:"p"},"CommandQueue"),". That queue is drained at a specific time in the state machine, thus all actions are executed in a serial manner, which is\nnecessary to again avoid race conditions."),(0,r.kt)("h2",{id:"when-to-use-it"},"When to use it"),(0,r.kt)("p",null,"Whenever access a shared resource like a TP is required, the respective piece of code be wrapped in a ",(0,r.kt)("inlineCode",{parentName:"p"},"CommandHandler")," and enqueued in the ",(0,r.kt)("inlineCode",{parentName:"p"},"CommandQueue"),". The\nCommandQueue will then execute the code safely and without side effects."),(0,r.kt)("h2",{id:"how-to-use-it"},"How to use it"),(0,r.kt)("p",null,"First it's important to note that ",(0,r.kt)("inlineCode",{parentName:"p"},"Commands")," are mere POJOs, their contract is that they are fully serializable, so they cannot have references to any\nnon-serializable objects."),(0,r.kt)("p",null,"Commands typically contain the data, that the ",(0,r.kt)("inlineCode",{parentName:"p"},"CommandHandler")," needs to execute the code, for example the ID of a transfer process. ",(0,r.kt)("inlineCode",{parentName:"p"},"CommandHandler"),"s must be\nregistered at runtime start, which is typically done in a ",(0,r.kt)("inlineCode",{parentName:"p"},"ServiceExtension"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public class YourExtension {\n    @Inject\n    private CommandHandlerRegistry registry;\n\n    @Override\n    public void initialize() {\n        var commandHandler = new HelloCommandHandler(); //handles HelloCommands commands\n        registry.register(commandHandler);\n    }\n}\n")),(0,r.kt)("p",null,"Whenever a ",(0,r.kt)("inlineCode",{parentName:"p"},"HelloCommand")," command needs to be issued in client code, a reference to the ",(0,r.kt)("inlineCode",{parentName:"p"},"CommandQueue")," is required. For safety reasons the ",(0,r.kt)("inlineCode",{parentName:"p"},"CommandQueue"),"\nis not exposed directly, but only accessible through e.g. a ",(0,r.kt)("inlineCode",{parentName:"p"},"TransferProcessManager"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},"public class ClientClass {\n\n    private TransferProcessManager tpm;\n\n    public void sayHello() {\n        var command = new HelloCommand();\n        tpm.enqueueCommand(command);\n    }\n}\n")),(0,r.kt)("p",null,"After that, the command will get executed eventually, but there is no guarantee with regard to latency, timeouts, ordering or resilience. The only certainty is\nthat the command will be executed once. If it fails, it gets re-enqueued, or discarded, if its retry cycles are exhausted."),(0,r.kt)("p",null,"Note that there is no direct back channel to the issuer of the command. While it would have been easy to add a ",(0,r.kt)("inlineCode",{parentName:"p"},"CompletableFuture")," as return type, it would\nviolate the serializability principle."),(0,r.kt)("h2",{id:"best-practices"},"Best practices"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"do not maintain any references to non-serializable objects in the ",(0,r.kt)("inlineCode",{parentName:"li"},"Command")," object"),(0,r.kt)("li",{parentName:"ul"},"Commands should not have behaviour, only state"),(0,r.kt)("li",{parentName:"ul"},"Command handlers should not have state, only behaviour"),(0,r.kt)("li",{parentName:"ul"},"As command handlers must be stateless, they must determine their state, for example by executing a database ",(0,r.kt)("inlineCode",{parentName:"li"},"read()")," directly in its ",(0,r.kt)("inlineCode",{parentName:"li"},"handle()")," method."),(0,r.kt)("li",{parentName:"ul"},"Command handlers must be defensive, for example they must check whether a transfer process can be modified or not."),(0,r.kt)("li",{parentName:"ul"},"Command handler should not implement long-running operations, as they may hold up calling components such as the TPM."),(0,r.kt)("li",{parentName:"ul"},"if command handlers throw an exception, the command may get retried, so proper cleanup must be done."),(0,r.kt)("li",{parentName:"ul"},"wrap all ",(0,r.kt)("inlineCode",{parentName:"li"},"enqueue")," operations in a ",(0,r.kt)("inlineCode",{parentName:"li"},"try-catch")," block, because enqueuing may fail with an ",(0,r.kt)("inlineCode",{parentName:"li"},"IllegalStateException"),", e.g. when the queue is full (bounded queue)"),(0,r.kt)("li",{parentName:"ul"},"do not expose the ",(0,r.kt)("inlineCode",{parentName:"li"},"CommandQueue")," directly - clients should only be able to enqueue items.")),(0,r.kt)("h2",{id:"further-reading"},"Further reading"),(0,r.kt)("p",null,"A complete sample with additional explanation can be found in the ",(0,r.kt)("a",{parentName:"p",href:"/edc-docs/docs/submodule/Connector/samples/04.2-modify-transferprocess/"},"samples"),"."))}u.isMDXComponent=!0}}]);