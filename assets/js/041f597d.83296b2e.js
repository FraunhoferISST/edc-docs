"use strict";(self.webpackChunkedc_docs=self.webpackChunkedc_docs||[]).push([[4844],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>u});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,r=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),d=p(n),u=o,h=d["".concat(l,".").concat(u)]||d[u]||m[u]||r;return n?a.createElement(h,i(i({ref:t},c),{},{components:n})):a.createElement(h,i({ref:t},c))}));function u(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var r=n.length,i=new Array(r);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var p=2;p<r;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},17742:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>r,metadata:()=>s,toc:()=>p});var a=n(87462),o=(n(67294),n(3905));const r={},i="Release Management of Dataspace Components",s={unversionedId:"submodule/Connector/docs/developer/decision-records/2022-11-28-release-management/README",id:"submodule/Connector/docs/developer/decision-records/2022-11-28-release-management/README",title:"Release Management of Dataspace Components",description:"Decision",source:"@site/docs/submodule/Connector/docs/developer/decision-records/2022-11-28-release-management/README.md",sourceDirName:"submodule/Connector/docs/developer/decision-records/2022-11-28-release-management",slug:"/submodule/Connector/docs/developer/decision-records/2022-11-28-release-management/",permalink:"/edc-docs/docs/submodule/Connector/docs/developer/decision-records/2022-11-28-release-management/",draft:!1,editUrl:"https://github.com/FraunhoferISST/edc-docs/tree/master/docs/submodule/Connector/docs/developer/decision-records/2022-11-28-release-management/README.md",tags:[],version:"current",frontMatter:{}},l={},p=[{value:"Decision",id:"decision",level:2},{value:"Rationale",id:"rationale",level:2},{value:"Homogenous releases",id:"homogenous-releases",level:3},{value:"Approach",id:"approach",level:2},{value:"Automatic releases",id:"automatic-releases",level:3},{value:"Manual releases",id:"manual-releases",level:3},{value:"Implementation notes",id:"implementation-notes",level:2}],c={toc:p};function m(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"release-management-of-dataspace-components"},"Release Management of Dataspace Components"),(0,o.kt)("h2",{id:"decision"},"Decision"),(0,o.kt)("p",null,'EDC\'s release management will undergo some refactoring/restructuring to be able to accommodate various requirements that\narise from other projects as well as the distributed nature of the components themselves. The term "release management"\nsolely refers to the ',(0,o.kt)("a",{parentName:"p",href:"https://ci.eclipse.org/edc"},"Jenkins build server"),' we use, i.e. to the "delivery" part in "CI/CD".'),(0,o.kt)("h2",{id:"rationale"},"Rationale"),(0,o.kt)("p",null,"The complexity of the EDC project grown quite a bit over the past months so that we now have these separate components,\nall of which are hosted in separate Git repositories."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Build: contains runtime metamodel and Gradle plugins"),(0,o.kt)("li",{parentName:"ul"},'Connector (sometimes referred to as the "Core")'),(0,o.kt)("li",{parentName:"ul"},"Federated Catalog"),(0,o.kt)("li",{parentName:"ul"},"Identity Hub"),(0,o.kt)("li",{parentName:"ul"},"Registration Service"),(0,o.kt)("li",{parentName:"ul"},"(Minimum Viable Dataspace: does not publish any artifacts)")),(0,o.kt)("p",null,"These components have dependencies onto one another, yet we will use one and the same version for all of them (\ncf. ",(0,o.kt)("a",{parentName:"p",href:"../2022-08-11-versioning_and_artifacts"},"decision record 2022-08-11"),"). However, it has become apparent that having a\ncommon release strategy for all of them is necessary to avoid version clashes and maintain our development velocity."),(0,o.kt)("p",null,"When we publish to MavenCentral, all components must be released with the same version. To avoid feature gaps between\nreleases, we need to verify compatibility amongst the components on a daily basis."),(0,o.kt)("h3",{id:"homogenous-releases"},"Homogenous releases"),(0,o.kt)("p",null,"By that we mean that all components should always have the same version number. That implies, that every component\ndepends on other components with the ",(0,o.kt)("em",{parentName:"p"},"same version number"),". For example, version ",(0,o.kt)("inlineCode",{parentName:"p"},"0.0.3")," of the Registration\nService would depend on version ",(0,o.kt)("inlineCode",{parentName:"p"},"0.0.3")," of the Runtime Metamodel, the Connector and the IdentityHub. In turn,\nthat implies, that before we can build and release Registration Service ",(0,o.kt)("inlineCode",{parentName:"p"},"0.0.3"),", we ",(0,o.kt)("strong",{parentName:"p"},"must")," release that exact\nversion of all the other components. Only then can we update the dependencies and start the release process."),(0,o.kt)("h2",{id:"approach"},"Approach"),(0,o.kt)("p",null,"We will separate our releases into two major categories: ",(0,o.kt)("em",{parentName:"p"},"automatic")," and ",(0,o.kt)("em",{parentName:"p"},"manual")," releases. While the earlier is\ntriggered either by an external system, such as Github or by a cron job, the latter is done only on-demand upon human\ninteraction."),(0,o.kt)("h3",{id:"automatic-releases"},"Automatic releases"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"SNAPSHOT")," builds")," are created for every component. Every commit on the ",(0,o.kt)("inlineCode",{parentName:"li"},"main")," branch of every component triggers\na\nsnapshot build."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Nightly components build"),": a build job triggers ",(0,o.kt)("inlineCode",{parentName:"li"},"SNAPSHOT")," releases of all components in sequence. The purpose of\nthis\nis to verify, that all components are still compatible to each other and to identify broken APIs/SPIs. This works\nbecause every component uses a ",(0,o.kt)("inlineCode",{parentName:"li"},"SNAPSHOT")," version of the other components, and dependent components are\nbuilt/released first. ",(0,o.kt)("br",null),"\nAs it stands, that sequence\nis ",(0,o.kt)("inlineCode",{parentName:"li"},"runtime-metamodel -> connector -> [federated-catalog, identity-hub] -> registration-service"),"."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Nightly tagged build"),': after the "nightly components build" has successfully completed, every component releases\na "\ntagged" version, i.e. a snapshot version with metadata that doesn\'t get overwritten, e.g. ',(0,o.kt)("inlineCode",{parentName:"li"},"0.0.1-20221128-SNAPSHOT"),".\nIn order to make it truly repeatable, every component must update its dependencies to other dependencies.\nThe purpose of this is to allow for repeatable builds in client applications, while keeping feature gaps to a\nminimum.")),(0,o.kt)("h3",{id:"manual-releases"},"Manual releases"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Release-by-tag"),": the build job lets the user select a Git tag and a ",(0,o.kt)("inlineCode",{parentName:"li"},"VERSION")," string as input and builds the\nspecified\nversion based on the given tag."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Release-by-branch"),": the build job lets the user select a Git branch and a ",(0,o.kt)("inlineCode",{parentName:"li"},"VERSION")," string as input and builds the\nspecified version based on the given branch."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"Release components"),': all components are built and released. For actual releases, i.e. artifacts that get published\nto\nMavenCentral, we need a build job that accepts the version as input parameter, and then triggers all downstream\nprojects with that same version. This is similar to the "Nightly components build".')),(0,o.kt)("h2",{id:"implementation-notes"},"Implementation notes"),(0,o.kt)("p",null,"As many of the aforementioned builds jobs are quite similar, we should try to create reusable pipelines in Jenkins. For\nexample, a pipeline to build and release all the components is used in two contexts."),(0,o.kt)("p",null,"One way of doing this is creating a parameterized job, that accepts the Git repo, a version string and an optional git\nref as input. So we have ",(0,o.kt)("em",{parentName:"p"},"one")," job, that is invoked with different parameters for every component or release scenario."),(0,o.kt)("p",null,"Then, once we have that modular pipeline in place, we can create ",(0,o.kt)("em",{parentName:"p"},"trigger pipelines"),", i.e. pipelines with the sole\npurpose of triggering other jobs. They can also have post-build hooks such as notifying Discord or sending emails."))}m.isMDXComponent=!0}}]);