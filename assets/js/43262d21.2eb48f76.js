"use strict";(self.webpackChunkedc_docs=self.webpackChunkedc_docs||[]).push([[2500],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var o=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,a=function(e,t){if(null==e)return{};var n,o,a={},r=Object.keys(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(o=0;o<r.length;o++)n=r[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=o.createContext({}),s=function(e){var t=o.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=s(e.components);return o.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},u=o.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,c=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),u=s(n),m=a,f=u["".concat(c,".").concat(m)]||u[m]||d[m]||r;return n?o.createElement(f,i(i({ref:t},p),{},{components:n})):o.createElement(f,i({ref:t},p))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,i=new Array(r);i[0]=u;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var s=2;s<r;s++)i[s]=n[s];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}u.displayName="MDXCreateElement"},9411:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>r,metadata:()=>l,toc:()=>s});var o=n(7462),a=(n(7294),n(3905));const r={},i="Decision",l={unversionedId:"submodule/Connector/docs/developer/decision-records/2022-11-09-api-refactoring/documentation",id:"submodule/Connector/docs/developer/decision-records/2022-11-09-api-refactoring/documentation",title:"Decision",description:"We will move away from one comprehensive openapi.yaml file and move towards creating separate OpenAPI specifications",source:"@site/docs/submodule/Connector/docs/developer/decision-records/2022-11-09-api-refactoring/documentation.md",sourceDirName:"submodule/Connector/docs/developer/decision-records/2022-11-09-api-refactoring",slug:"/submodule/Connector/docs/developer/decision-records/2022-11-09-api-refactoring/documentation",permalink:"/edc-docs/docs/submodule/Connector/docs/developer/decision-records/2022-11-09-api-refactoring/documentation",draft:!1,editUrl:"https://github.com/FraunhoferISST/edc-docs/tree/master/docs/submodule/Connector/docs/developer/decision-records/2022-11-09-api-refactoring/documentation.md",tags:[],version:"current",frontMatter:{}},c={},s=[],p={toc:s};function d(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,o.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"decision"},"Decision"),(0,a.kt)("p",null,"We will move away from one comprehensive ",(0,a.kt)("inlineCode",{parentName:"p"},"openapi.yaml")," file and move towards creating separate OpenAPI specifications\nfor all of our APIs and publish them to SwaggerHub separately."),(0,a.kt)("h1",{id:"rationale"},"Rationale"),(0,a.kt)("p",null,"EDC offers several APIs, which differ in their intended usage scenario, their visibility and likely their\nauthentication mechanism. For example, the Management API is intended for consumption by external clients, whereas the\ncontrol API is intended to facilitate communication between data plane and control plane. It is therefor likely that the\nrespective documentation (i.e. Swagger) will be consumed by different user groups."),(0,a.kt)("p",null,"Adding to this is the fact that we're publishing different APIs under different ports and context paths, which makes it\ndifficult (if not impossible) to provide separate ",(0,a.kt)("inlineCode",{parentName:"p"},"@Server")," sections for each them. That means, that ",(0,a.kt)("em",{parentName:"p"},"all")," APIs would\neffectively hit a server at the same port and base path. There is the ",(0,a.kt)("inlineCode",{parentName:"p"},"@ServerVariable")," annotation, but again, that\nwould affect all endpoints in a single YAML file equally."),(0,a.kt)("h1",{id:"approach"},"Approach"),(0,a.kt)("p",null,'Every module that contains an API, i.e. a controller class annotated with Swagger annotations, produces a YAML file that\ncontains documentation about its controllers. We\'ll have to find a way to group together several of these "partial\nspecs". For example, the Management API is made up of the Asset API, the Policy API, etc., so we need to merge them into\na ',(0,a.kt)("inlineCode",{parentName:"p"},"management-api.yaml")," file."),(0,a.kt)("p",null,"One possible approach to achieve this would be to either utilize the ",(0,a.kt)("inlineCode",{parentName:"p"},"@Tags")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"@Tag")," annotations, or come up with\ncustom annotations, and extend or wrap around the ",(0,a.kt)("inlineCode",{parentName:"p"},"resolve")," Gradle task (from the Swagger plugin), so that input\nfiles/directories are grouped together based on these annotations."),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"Note: writing a custom Gradle plugin/task for this could become necessary")),(0,a.kt)("p",null,"For example, every controller that is annotated with ",(0,a.kt)("inlineCode",{parentName:"p"},'@ApiGroup(name="management-api")')," would produce\na partial spec, i.e. a ",(0,a.kt)("inlineCode",{parentName:"p"},"<modulename>.yaml")," file, which contains the controller's documentation and that - during the\nmerging would contribute to a ",(0,a.kt)("inlineCode",{parentName:"p"},"management-api.yaml")," file."),(0,a.kt)("p",null,"Technically speaking there would have to be a subfolder called e.g. ",(0,a.kt)("inlineCode",{parentName:"p"},"management-api"),", into which all partial spec files\nare put. Then, the ",(0,a.kt)("inlineCode",{parentName:"p"},"mergeOpenApiFiles")," task would have to be invoked for every one of these subfolders, thus merging its\ncontents and ultimately producing the (merged) ",(0,a.kt)("inlineCode",{parentName:"p"},"management-api.yaml"),"."),(0,a.kt)("p",null,'Similarly, when merging the "partial specs" together using the ',(0,a.kt)("inlineCode",{parentName:"p"},"openApiMerger"),", we'd get several API specs,\ne.g. ",(0,a.kt)("inlineCode",{parentName:"p"},"management-api.yaml"),", ",(0,a.kt)("inlineCode",{parentName:"p"},"control-api.yaml"),", etc."),(0,a.kt)("p",null,"Ultimately, all of these will get published as separate APIs to SwaggerHub."))}d.isMDXComponent=!0}}]);