"use strict";(self.webpackChunkedc_docs=self.webpackChunkedc_docs||[]).push([[7911],{3905:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>h});var a=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},c=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},m=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=p(n),h=i,u=m["".concat(l,".").concat(h)]||m[h]||d[h]||o;return n?a.createElement(u,r(r({ref:t},c),{},{components:n})):a.createElement(u,r({ref:t},c))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,r=new Array(o);r[0]=m;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:i,r[1]=s;for(var p=2;p<o;p++)r[p]=n[p];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}m.displayName="MDXCreateElement"},18400:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var a=n(87462),i=(n(67294),n(3905));const o={},r="Issuing dynamic queries in SQL data stores",s={unversionedId:"submodule/Connector/docs/developer/sql_queries",id:"submodule/Connector/docs/developer/sql_queries",title:"Issuing dynamic queries in SQL data stores",description:"Introduction",source:"@site/docs/submodule/Connector/docs/developer/sql_queries.md",sourceDirName:"submodule/Connector/docs/developer",slug:"/submodule/Connector/docs/developer/sql_queries",permalink:"/edc-docs/docs/submodule/Connector/docs/developer/sql_queries",draft:!1,editUrl:"https://github.com/FraunhoferISST/edc-docs/tree/master/docs/submodule/Connector/docs/developer/sql_queries.md",tags:[],version:"current",frontMatter:{}},l={},p=[{value:"Introduction",id:"introduction",level:2},{value:"Preliminary: the canonical format",id:"preliminary-the-canonical-format",level:2},{value:"Using <code>TranslationMapping</code>",id:"using-translationmapping",level:2},{value:"Mapping primitive fields",id:"mapping-primitive-fields",level:3},{value:"Mapping complex objects",id:"mapping-complex-objects",level:3},{value:"Option 1: using foreign keys",id:"option-1-using-foreign-keys",level:4},{value:"Option 2a: encoding the object in JSON",id:"option-2a-encoding-the-object-in-json",level:4},{value:"Option 2b: encoding lists/arrays in JSON",id:"option-2b-encoding-listsarrays-in-json",level:4},{value:"Prepared statements using the <code>SqlQueryStatement</code>",id:"prepared-statements-using-the-sqlquerystatement",level:2},{value:"Specific features for PostgreSQL",id:"specific-features-for-postgresql",level:2},{value:"Supported query operators",id:"supported-query-operators",level:2},{value:"Comparison with NoSQL databases (CosmosDB)",id:"comparison-with-nosql-databases-cosmosdb",level:2}],c={toc:p};function d(e){let{components:t,...o}=e;return(0,i.kt)("wrapper",(0,a.Z)({},c,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"issuing-dynamic-queries-in-sql-data-stores"},"Issuing dynamic queries in SQL data stores"),(0,i.kt)("h2",{id:"introduction"},"Introduction"),(0,i.kt)("p",null,"The Management API (DM API) offers a very open and unrestricted query feature: as long as it can be expressed as a\n3-tuple in the form"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"<LEFT_OPERAND> <OPERATOR> <RIGHT_OPERAND>\n")),(0,i.kt)("p",null,"it is a valid query. This abstract way of expressing a condition is called a ",(0,i.kt)("inlineCode",{parentName:"p"},"Criterion"),". For example, API clients may\nspecify a query to obtain a selection of ",(0,i.kt)("inlineCode",{parentName:"p"},"ContractNegotiation")," objects that looks like this:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"contractAgreement.assetId = myAssetId\n")),(0,i.kt)("p",null,"In practice this would return ",(0,i.kt)("inlineCode",{parentName:"p"},"ContractNegotiation"),"s, that have a ",(0,i.kt)("inlineCode",{parentName:"p"},"ContractAgreement")," which references an ",(0,i.kt)("inlineCode",{parentName:"p"},"Asset")," with\nthe ID ",(0,i.kt)("inlineCode",{parentName:"p"},'"myAssetId"'),"."),(0,i.kt)("p",null,"This means, that the backing ",(0,i.kt)("inlineCode",{parentName:"p"},"SqlContractNegotiationStore")," must be able to do the following things:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"dynamically map the expression onto it's internal DB schema: a mapping from the properties ",(0,i.kt)("inlineCode",{parentName:"li"},"contractAgreement")," onto\nthe column name ",(0,i.kt)("inlineCode",{parentName:"li"},"contract_agreement")," must be made. Furthermore, the store implementation must be able to determine\nhow to traverse from ",(0,i.kt)("inlineCode",{parentName:"li"},"ContractNegotiation")," to ",(0,i.kt)("inlineCode",{parentName:"li"},"ContractAgreement")," in the database, which in this case means\nnavigation (\n= ",(0,i.kt)("inlineCode",{parentName:"li"},"JOIN"),"-ing ) a foreign key."),(0,i.kt)("li",{parentName:"ol"},"distinguish between a scalar or a collection right-hand operand: operators such as ",(0,i.kt)("inlineCode",{parentName:"li"},"IN")," require the right-hand\noperand to be a list, such as ",(0,i.kt)("inlineCode",{parentName:"li"},"...WHERE x IN (y1,y1)")),(0,i.kt)("li",{parentName:"ol"},"substitute the values in the expression with placeholders for prepared statements (=",(0,i.kt)("inlineCode",{parentName:"li"},"?"),")"),(0,i.kt)("li",{parentName:"ol"},"leverage DB-specific features, like querying a JSON-encoded field, which would only be available in Postgres")),(0,i.kt)("p",null,"The following section explains how all of these are achieved."),(0,i.kt)("h2",{id:"preliminary-the-canonical-format"},"Preliminary: the canonical format"),(0,i.kt)("p",null,"Theoretically it is possible to map every schema onto every other schema, given that they are of equal cardinality. To\nachieve that, we introduce the notion of a ",(0,i.kt)("em",{parentName:"p"},"canonical format"),", which is our internal working schema. In other words,\nthis is the schema in which objects are represented internally. If in the future we support a wider variety of\ntranslation and transformation paths, everything would have to be transformed into that canonical format first."),(0,i.kt)("p",null,"In actuality the ",(0,i.kt)("em",{parentName:"p"},"canonical format")," of an object is defined by the respective Java class and its field names. For\ninstance, a query for contract negotiations must be specified using the field names of a ",(0,i.kt)("inlineCode",{parentName:"p"},"ContractNegotiation")," object:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"public class ContractNegotiation {\n    // ...\n    private ContractAgreement contractAgreement;\n    // ...\n}\n\npublic class ContractAgreement {\n    // ...\n    private final String assetId;\n}\n")),(0,i.kt)("p",null,"Consequently, ",(0,i.kt)("inlineCode",{parentName:"p"},"contractAgreement.assetId")," would be valid, whereas ",(0,i.kt)("inlineCode",{parentName:"p"},"contract_agreement.asset_id")," would not. Or, the\nleft-hand operand looks like as if we were traversing the Java object graph. This is what we call the ",(0,i.kt)("em",{parentName:"p"},"canonical format"),"\n. Note the omission of the root object ",(0,i.kt)("inlineCode",{parentName:"p"},"contractNegotiation"),"!"),(0,i.kt)("h2",{id:"using-translationmapping"},"Using ",(0,i.kt)("inlineCode",{parentName:"h2"},"TranslationMapping")),(0,i.kt)("p",null,"In order to decouple the canonical format and the SQL schema (or any other schema) in terms of naming convention, a\nmapping scheme exists to map the canonical model onto the SQL model. The ",(0,i.kt)("inlineCode",{parentName:"p"},"TranslationMapping")," is essentially a\ngraph-like metamodel of the business objects: every Java class is represented by a mapping class that contains its field\nnames and the associated SQL column names. The convention is to append ",(0,i.kt)("inlineCode",{parentName:"p"},"*Mapping")," to the class name,\ne.g. ",(0,i.kt)("inlineCode",{parentName:"p"},"PolicyDefinitionMapping"),"."),(0,i.kt)("h3",{id:"mapping-primitive-fields"},"Mapping primitive fields"),(0,i.kt)("p",null,"Primitive fields are stored directly in SQL columns (as opposed to JSON, foreign keys,...). Thus, mapping primitive data\ntypes is trivial: a simple mapping from one onto the other is necessary, for\nexample, ",(0,i.kt)("inlineCode",{parentName:"p"},"ContractNegotiation.counterPartyAddress")," would be represented in the metamodel as an entry"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},'"counterPartyAddress"->"counterparty_address"\n')),(0,i.kt)("p",null,"When constructing ",(0,i.kt)("inlineCode",{parentName:"p"},"WHERE/AND")," clauses, the canonical property must simply be replaced by the respective SQL column name."),(0,i.kt)("h3",{id:"mapping-complex-objects"},"Mapping complex objects"),(0,i.kt)("p",null,"For fields that are of complex type, such as the ",(0,i.kt)("inlineCode",{parentName:"p"},"ContractNegotiation.contractAgreement")," field, it is necessary to\naccommodate this depending on how the EDM is defined. There are two basic variants that we use:"),(0,i.kt)("h4",{id:"option-1-using-foreign-keys"},"Option 1: using foreign keys"),(0,i.kt)("p",null,"In this case, the referenced object is stored in a separate table using a foreign key. Thus, the canonical property\n(= ",(0,i.kt)("inlineCode",{parentName:"p"},"contractAgreement"),") is mapped onto the SQL schema using yet another ",(0,i.kt)("inlineCode",{parentName:"p"},"*Mapping")," class. In the given example this\nwould be the ",(0,i.kt)("inlineCode",{parentName:"p"},"ContractAgreementMapping"),". When resolving a property in the canonical format (",(0,i.kt)("inlineCode",{parentName:"p"},"contractAgreement.assetId"),")\n, this means we must recursively descend into the model graph and resolve the correct SQL expression."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Note: mapping and translating ",(0,i.kt)("inlineCode",{parentName:"em"},"one-to-many")," relations (= arrays/lists) with foreign keys is not implemented at this\ntime.")),(0,i.kt)("h4",{id:"option-2a-encoding-the-object-in-json"},"Option 2a: encoding the object in JSON"),(0,i.kt)("p",null,"Another way to store complex objects is to encode them in JSON and store them in a ",(0,i.kt)("inlineCode",{parentName:"p"},"VARCHAR")," column. Some databases even\nhave a special data type and dedicated operators and functions for that. Postgres is one of them. For example,\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"TranferProcess")," is stored in a table called ",(0,i.kt)("inlineCode",{parentName:"p"},"edc_transfer_process"),", its ",(0,i.kt)("inlineCode",{parentName:"p"},"DataAddress")," property is encoded in JSON\nand stored in a ",(0,i.kt)("inlineCode",{parentName:"p"},"JSON")," field."),(0,i.kt)("p",null,"For example querying for ",(0,i.kt)("inlineCode",{parentName:"p"},"TransferProcess")," objects: when mapping the filter\nexpression ",(0,i.kt)("inlineCode",{parentName:"p"},"contentDataAddress.properties.somekey=somevalue"),", the ",(0,i.kt)("inlineCode",{parentName:"p"},"contentDataAddress")," is represented as JSON, therefore\nin the ",(0,i.kt)("inlineCode",{parentName:"p"},"TransferProcessMapping")," the ",(0,i.kt)("inlineCode",{parentName:"p"},"contentDataAddress")," field maps to a ",(0,i.kt)("inlineCode",{parentName:"p"},"JsonFieldMapping"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-java"},"public TransferProcessMapping(TransferProcessStoreStatements statements){\n        // ...\n        add(FIELD_CONTENTDATAADDRESS,new JsonFieldMapping(statements.getContentDataAddressColumn()));\n        // ...\n        }\n")),(0,i.kt)("p",null,"which would then get translated to:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT *\nFROM edc_transfer_process\n-- omit LEFT OUTER JOIN for readability\nWHERE content_data_address -> 'properties' ->> 'key' = 'value'\n")),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"Note this statement is only valid in the Postgres dialect! Other SQL databases may or may not have similar\npossibilities.")),(0,i.kt)("h4",{id:"option-2b-encoding-listsarrays-in-json"},"Option 2b: encoding lists/arrays in JSON"),(0,i.kt)("p",null,"Like accessing objects, accessing lists/arrays of objects is possible using special JSON operators. In this case the\nspecial Postgres function ",(0,i.kt)("inlineCode",{parentName:"p"},"json_array_elements()")," is used. Please refer to\nthe ",(0,i.kt)("a",{parentName:"p",href:"https://www.postgresql.org/docs/9.5/functions-json.html"},"official documentation"),"."),(0,i.kt)("p",null,"For an example of how this is done, please look at how\nthe ",(0,i.kt)("a",{target:"_blank",href:n(12038).Z},"TransferProcessMapping"),"\nmaps a ",(0,i.kt)("inlineCode",{parentName:"p"},"ResourceManifest"),", which in turn contains a ",(0,i.kt)("inlineCode",{parentName:"p"},"List<ResourceDefinition>")," using\nthe ",(0,i.kt)("a",{target:"_blank",href:n(9115).Z},"ResourceManifestMapping"),"\n. Finally, the ",(0,i.kt)("inlineCode",{parentName:"p"},"SqlQueryStatement"),"\ngets ",(0,i.kt)("a",{target:"_blank",href:n(23934).Z},"assembled using the aforementioned JSON array function"),"\n."),(0,i.kt)("h2",{id:"prepared-statements-using-the-sqlquerystatement"},"Prepared statements using the ",(0,i.kt)("inlineCode",{parentName:"h2"},"SqlQueryStatement")),(0,i.kt)("p",null,"The first step of the translation, i.e. mapping from canonical format onto a target DSL, is handled by\nthe ",(0,i.kt)("inlineCode",{parentName:"p"},"TranslationMapping")," class and its implementors."),(0,i.kt)("p",null,"The second and third steps involve interpreting the right-hand operand as scalar or list-type and substituting its\nvalues with the appropriate placeholders for SQL prepared statements. This is done by the ",(0,i.kt)("inlineCode",{parentName:"p"},"SqlConditionExpression"),"\nclass, which validates the expression by checking the operator against a list of supported operators, and then converts\nthe right-hand operand in to either a single, or a list of placeholders. In SQL this is either ",(0,i.kt)("inlineCode",{parentName:"p"},"?")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"(?,?,...?)"),"."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"SqlQueryStatement")," wraps both these two steps (translation and substitution) and offers a convenient API."),(0,i.kt)("h2",{id:"specific-features-for-postgresql"},"Specific features for PostgreSQL"),(0,i.kt)("p",null,"As mentioned before Postgres has data types and query operators specifically to store and query JSON structures\n(see ",(0,i.kt)("a",{parentName:"p",href:"https://www.postgresql.org/docs/12/functions-json.html"},"official documentation"),"). In order to leverage that, some\nparts of the object graph are persisted as JSON rather than in a separate table referenced by foreign key."),(0,i.kt)("p",null,"The condition of the",(0,i.kt)("inlineCode",{parentName:"p"},"WHERE")," clause is in fact contributed by the ",(0,i.kt)("inlineCode",{parentName:"p"},"*Mapping")," class that is specific to Postgres."),(0,i.kt)("p",null,"Notes:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Querying list/array types using Postgres' JSON features requires modifying the ",(0,i.kt)("inlineCode",{parentName:"li"},"SELECT")," statement, as the cast to a\nJSON array is done on the fly. Therefore, this has to be done ",(0,i.kt)("em",{parentName:"li"},"before")," constructing the ",(0,i.kt)("inlineCode",{parentName:"li"},"SqlQueryStatement"),"."),(0,i.kt)("li",{parentName:"ul"},"in order to port this to another database dialect, the ",(0,i.kt)("inlineCode",{parentName:"li"},"Mapping")," classes very likely will have to be reimplemented")),(0,i.kt)("h2",{id:"supported-query-operators"},"Supported query operators"),(0,i.kt)("p",null,"Currently we only support the following operators:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"="),": equality, right-hand operand is interpreted as literal"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"in"),': "one-of", right hand operand must be an ',(0,i.kt)("inlineCode",{parentName:"li"},"Iterable")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"like"),": pattern matching, right-hand operand is interpreted\nas ",(0,i.kt)("a",{parentName:"li",href:"https://www.w3schools.com/sql/sql_like.asp"},"pattern string"))),(0,i.kt)("h2",{id:"comparison-with-nosql-databases-cosmosdb"},"Comparison with NoSQL databases (CosmosDB)"),(0,i.kt)("p",null,"In CosmosDB this translation is not necessary, as the domain object is wrapped in a ",(0,i.kt)("inlineCode",{parentName:"p"},"CosmosDocument")," and directly\nserialized to JSON. In other words, the canonical format is congruent to the CosmosDB schema. However, CosmosDB uses a\nsimilar method to dynamically generate ",(0,i.kt)("inlineCode",{parentName:"p"},"SELECT")," statements."))}d.isMDXComponent=!0},23934:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/PostgresDialectStatements-75aa68bb4d0a3f0b5f99178e8c5ae4f6.java"},9115:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/ResourceManifestMapping-be5fd4bd99698533c9a51da8206e9bfb.java"},12038:(e,t,n)=>{n.d(t,{Z:()=>a});const a=n.p+"assets/files/TransferProcessMapping-a0eeaab03a077362bcaa1133c9b3d2e2.java"}}]);