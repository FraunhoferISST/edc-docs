"use strict";(self.webpackChunkedc_docs=self.webpackChunkedc_docs||[]).push([[3961],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var s=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);t&&(s=s.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,s)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,s,r=function(e,t){if(null==e)return{};var n,s,r={},a=Object.keys(e);for(s=0;s<a.length;s++)n=a[s],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(s=0;s<a.length;s++)n=a[s],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=s.createContext({}),l=function(e){var t=s.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=l(e.components);return s.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return s.createElement(s.Fragment,{},t)}},p=s.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,c=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),p=l(n),h=r,v=p["".concat(c,".").concat(h)]||p[h]||u[h]||a;return n?s.createElement(v,i(i({ref:t},d),{},{components:n})):s.createElement(v,i({ref:t},d))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,i=new Array(a);i[0]=p;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType="string"==typeof e?e:r,i[1]=o;for(var l=2;l<a;l++)i[l]=n[l];return s.createElement.apply(null,i)}return s.createElement.apply(null,n)}p.displayName="MDXCreateElement"},7951:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>o,toc:()=>l});var s=n(7462),r=(n(7294),n(3905));const a={},i="Unify asynchronous code testing practices",o={unversionedId:"submodule/Connector/docs/developer/decision-records/2022-08-04-async-code-testing-practices/README",id:"submodule/Connector/docs/developer/decision-records/2022-08-04-async-code-testing-practices/README",title:"Unify asynchronous code testing practices",description:"Decision",source:"@site/docs/submodule/Connector/docs/developer/decision-records/2022-08-04-async-code-testing-practices/README.md",sourceDirName:"submodule/Connector/docs/developer/decision-records/2022-08-04-async-code-testing-practices",slug:"/submodule/Connector/docs/developer/decision-records/2022-08-04-async-code-testing-practices/",permalink:"/edc-docs/docs/submodule/Connector/docs/developer/decision-records/2022-08-04-async-code-testing-practices/",draft:!1,editUrl:"https://github.com/FraunhoferISST/edc-docs/tree/master/docs/submodule/Connector/docs/developer/decision-records/2022-08-04-async-code-testing-practices/README.md",tags:[],version:"current",frontMatter:{}},c={},l=[{value:"Decision",id:"decision",level:2},{value:"Rationale",id:"rationale",level:2},{value:"Approach",id:"approach",level:2},{value:"class <code>AssetEventDispatchTest</code>",id:"class-asseteventdispatchtest",level:3},{value:"with CountDownLatch",id:"with-countdownlatch",level:4},{value:"with awaitility",id:"with-awaitility",level:4},{value:"Additional Note:",id:"additional-note",level:3}],d={toc:l};function u(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,s.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"unify-asynchronous-code-testing-practices"},"Unify asynchronous code testing practices"),(0,r.kt)("h2",{id:"decision"},"Decision"),(0,r.kt)("p",null,"Currently, the testing of async code is performed in two different ways:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"using the ",(0,r.kt)("inlineCode",{parentName:"li"},"CoundDownLatch")," object"),(0,r.kt)("li",{parentName:"ul"},"using the ",(0,r.kt)("inlineCode",{parentName:"li"},"Awaitility")," library")),(0,r.kt)("p",null,"The goal of ",(0,r.kt)("inlineCode",{parentName:"p"},"CountDownLatch")," objects and the ",(0,r.kt)("inlineCode",{parentName:"p"},"Awaitility")," library is to block a thread until other threads have\ncompleted a particular task. This is useful for testing asynchronous threads."),(0,r.kt)("p",null,"The idea is to avoid using ",(0,r.kt)("inlineCode",{parentName:"p"},"CoundDownLatch")," and start only using ",(0,r.kt)("inlineCode",{parentName:"p"},"Awaitility"),"."),(0,r.kt)("h2",{id:"rationale"},"Rationale"),(0,r.kt)("p",null,"Testing asynchronous systems is difficult. It requires not only handling threads, timeouts and concurrency issues, but\nalso the intent of the test code can be obscured by all these details. Awaitility is a DSL that allows to express\nexpectations of an asynchronous system in a conciser and easier to read manner than CountdownLatch."),(0,r.kt)("h2",{id:"approach"},"Approach"),(0,r.kt)("p",null,"Awaitility permits to check multiple asynchronous behaviors at the same time with assertions that are included in the\nuntilAsserted block that will by default poll the assertions every 100 ms until either the assertions are valid or the\ntimeout expires which is by default 10 seconds."),(0,r.kt)("p",null,"The following is a comparative of the current code with CountDownLatch and the proposal with Awaitility in one test:"),(0,r.kt)("h3",{id:"class-asseteventdispatchtest"},"class ",(0,r.kt)("inlineCode",{parentName:"h3"},"AssetEventDispatchTest")),(0,r.kt)("h4",{id:"with-countdownlatch"},"with CountDownLatch"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'public class AssetEventDispatchTest {\n    //...\n    @Test\n    void shouldDispatchEventsOnAssetCreationAndDeletion(AssetService service, EventRouter eventRouter) throws InterruptedException {\n        var createdLatch = onDispatchLatch(AssetCreated.class);\n        var deletedLatch = onDispatchLatch(AssetDeleted.class);\n        eventRouter.register(eventSubscriber);\n        var asset = Asset.Builder.newInstance().id("assetId").build();\n        var dataAddress = DataAddress.Builder.newInstance().type("any").build();\n\n        service.create(asset, dataAddress);\n\n        assertThat(createdLatch.await(10, SECONDS)).isTrue();\n        verify(eventSubscriber).on(isA(AssetCreated.class));\n\n        service.delete(asset.getId());\n\n        assertThat(deletedLatch.await(10, SECONDS)).isTrue();\n        verify(eventSubscriber).on(isA(AssetDeleted.class));\n    }\n\n    private CountDownLatch onDispatchLatch(Class<? extends Event> eventType) {\n        var latch = new CountDownLatch(1);\n\n        doAnswer(i -> {\n            latch.countDown();\n            return null;\n        }).when(eventSubscriber).on(isA(eventType));\n\n        return latch;\n    }\n}\n')),(0,r.kt)("h4",{id:"with-awaitility"},"with awaitility"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-java"},'public class AssetEventDispatchTest {\n    //...\n    @Test\n    void shouldDispatchEventsOnAssetCreationAndDeletion(AssetService service, EventRouter eventRouter) {\n\n        doAnswer(i -> {\n            return null;\n        }).when(eventSubscriber).on(isA(AssetCreated.class));\n\n        doAnswer(i -> {\n            return null;\n        }).when(eventSubscriber).on(isA(AssetDeleted.class));\n\n        eventRouter.register(eventSubscriber);\n        var asset = Asset.Builder.newInstance().id("assetId").build();\n        var dataAddress = DataAddress.Builder.newInstance().type("any").build();\n\n        service.create(asset, dataAddress);\n        await().untilAsserted(() -> {\n            verify(eventSubscriber).on(isA(AssetCreated.class));\n        });\n\n        service.delete(asset.getId());\n        await().untilAsserted(() -> {\n            verify(eventSubscriber).on(isA(AssetDeleted.class));\n        });\n    }\n}\n')),(0,r.kt)("h3",{id:"additional-note"},"Additional Note:"),(0,r.kt)("p",null,"class ",(0,r.kt)("inlineCode",{parentName:"p"},"TransferProcessManagerImplTest"),"\n(core\\transfer\\src\\test\\java\\org\\eclipse\\dataspaceconnector\\transfer\\core\\transfer\\TransferProcessManagerImplTest.java)\n",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("em",{parentName:"strong"}," In method verifyCompleted_noCheckerForManaged(): A latch was only instantiated but not used "))))}u.isMDXComponent=!0}}]);